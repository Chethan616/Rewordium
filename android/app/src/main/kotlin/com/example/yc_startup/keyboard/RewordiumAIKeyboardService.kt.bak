package com.example.yc_startup.keyboard

import android.annotation.SuppressLint
import android.content.Context
import android.content.SharedPreferences
import android.graphics.Color
import android.graphics.PorterDuff
import android.graphics.PorterDuffColorFilter
import android.graphics.Rect
import android.graphics.Paint as TextPaint
import android.graphics.drawable.GradientDrawable
import android.graphics.drawable.StateListDrawable
import com.example.yc_startup.keyboard.api.GroqApiClient
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import com.example.yc_startup.keyboard.dictionary.SuggestionDictionary
import android.inputmethodservice.InputMethodService
import android.os.Handler
import android.os.Looper
import android.os.SystemClock
import android.os.VibrationEffect
import android.os.Vibrator
import android.text.InputType
import android.text.TextUtils
import android.util.Log
import android.util.TypedValue
import android.view.*
import android.view.animation.Animation
import android.view.animation.AnimationUtils
import android.widget.Toast
import android.view.animation.DecelerateInterpolator
import android.view.animation.ScaleAnimation
import android.view.inputmethod.EditorInfo
import android.view.inputmethod.InputConnection
import android.view.inputmethod.InputMethodManager
import android.widget.*
import androidx.core.content.ContextCompat
import androidx.core.graphics.drawable.DrawableCompat
import com.example.yc_startup.R

private const val TAG = "RewordiumAIKeyboard"
private const val PREFS_NAME = "RewordiumKeyboardPrefs"
private const val KEY_THEME_COLOR = "theme_color"
private const val KEY_DARK_MODE = "dark_mode"
private const val KEY_HAPTIC_FEEDBACK = "haptic_feedback"
private const val KEY_AUTO_CAPITALIZE = "auto_capitalize"
private const val KEY_DOUBLE_SPACE_PERIOD = "double_space_period"
private const val SWIPE_THRESHOLD = 50f // Added for spacebar swipe detection

// Enum to track keyboard state
enum class KeyboardState {
    LETTERS,
    SYMBOLS,
    EMOJI,
    PARAPHRASING
}

/**
 * A custom iOS-styled keyboard service with AI-powered features
 * that can be customized from the Flutter app settings.
 */
class RewordiumAIKeyboardService : InputMethodService() {
    // UI components
    private var inputView: View? = null
    private lateinit var keyboardContainer: LinearLayout
    private var gifView: pl.droidsonroids.gif.GifImageView? = null
    
    // Keyboard state tracking
    private var keyboardState: KeyboardState = KeyboardState.LETTERS
    
    // Suggestion bar components
    private lateinit var suggestionContainer: ViewGroup
    private lateinit var suggestionsTextView: TextView
    private var currentSuggestions: List<String> = emptyList()
    private var currentWord = ""
    private var isParaphrasingMode = false
    private var currentSentenceStart = 0
    private var suggestionWidths: List<Float> = emptyList()
    private var lastClickTime: Long = 0
    private var lastClickPosition: Int = -1
    private var lastInputText: String = ""
    private var lastCursorPosition: Int = 0
    // Use the SuggestionDictionary singleton
    
    // AI button variables
    private lateinit var aiButton: FrameLayout
    
    // Paraphrase view variables
    private var paraphraseView: View? = null
    private var paraphraseOptionsContainer: LinearLayout? = null
    private var paraphraseLoadingContainer: FrameLayout? = null
    private var originalTextView: TextView? = null
    private var optionContainers = arrayOfNulls<LinearLayout>(3)
    private var optionTextViews = arrayOfNulls<TextView>(3)
    
    // Keyboard layout containers
    private lateinit var symbolsKeyboardContainer: FrameLayout
    
    // Emoji keyboard variables
    private lateinit var emojiKeyboardContainer: FrameLayout
    private lateinit var emojiGridContainer: LinearLayout
    private lateinit var emojiCategoryIndicatorContainer: LinearLayout
    private lateinit var emojiCategoryTabsContainer: LinearLayout
    private lateinit var bottomRow: LinearLayout
    
    // Keyboard rows
    private lateinit var numberRow: LinearLayout
    private lateinit var rowQwerty: LinearLayout
    private lateinit var rowAsdf: LinearLayout
    private lateinit var rowZxcv: LinearLayout
    
    // Keyboard state
    private var isCapsOn = false  // Single shift mode (next character capitalized)
    private var isCapsLock = false  // Caps lock mode (all characters capitalized)
    private var isSymbolsShown = false
    private var isEmojiKeyboardShown = false
    private var lastSpaceTime: Long = 0
    private var lastKeyWasSpace = false
    private var lastShiftTime: Long = 0  // For detecting double-tap on shift
    
    // Theme settings
    private var themeColor = "#007AFF" // Default iOS blue
    private var isDarkMode = false
    private var isHapticFeedbackEnabled = true
    private var isAutoCapitalizeEnabled = true
    private var isDoubleSpacePeriodEnabled = true

    // Emoji Keyboard State
    private var currentEmojiCategoryIndex = 0
    
    private val emojiCategories = listOf(
        "Emoticons" to listOf( // U+1F600 - U+1F64F
            "ğŸ˜€", "ğŸ˜", "ğŸ˜‚", "ğŸ˜ƒ", "ğŸ˜„", "ğŸ˜…", "ğŸ˜†", "ğŸ˜‡", "ğŸ˜ˆ", "ğŸ˜‰", "ğŸ˜Š", "ğŸ˜‹", "ğŸ˜", "ğŸ˜", "ğŸ˜", "ğŸ˜", "ğŸ˜‘", "ğŸ˜’", "ğŸ˜“", "ğŸ˜”", "ğŸ˜•", "ğŸ˜–", "ğŸ˜—", "ğŸ˜˜",
            "ğŸ˜™", "ğŸ˜š", "ğŸ˜›", "ğŸ˜œ", "ğŸ˜", "ğŸ˜", "ğŸ˜Ÿ", "ğŸ˜ ", "ğŸ˜¡", "ğŸ˜¢", "ğŸ˜£", "ğŸ˜¤", "ğŸ˜¥", "ğŸ˜¦", "ğŸ˜§", "ğŸ˜¨", "ğŸ˜©", "ğŸ˜ª", "ğŸ˜«", "ğŸ˜¬", "ğŸ˜®", "ğŸ˜¯", "ğŸ˜°", "ğŸ˜±",
            "ğŸ˜²", "ğŸ˜³", "ğŸ˜´", "ğŸ˜µ", "ğŸ˜¶", "ğŸ˜·", "ğŸ™", "ğŸ™‚", "ğŸ™ƒ", "ğŸ™„", "ğŸ¤", "ğŸ¤‘", "ğŸ¤’", "ğŸ¤“", "ğŸ¤”", "ğŸ¤•", "ğŸ¤—", "ğŸ¤", "ğŸ¤¨", "ğŸ¤©", "ğŸ¤ª", "ğŸ¤«", "ğŸ¤¬", "ğŸ¤­",
            "ğŸ¤®", "ğŸ¤¯", "ğŸ§"
        ),
        "Misc Symbols & Pictographs" to listOf( // U+1F300 - U+1F5FF
            "ğŸŒ", "ğŸŒ‚", "ğŸŒƒ", "ğŸŒ„", "ğŸŒ…", "ğŸŒ†", "ğŸŒ‡", "ğŸŒˆ", "ğŸŒ‰", "ğŸŒŠ", "ğŸŒ‹", "ğŸŒŒ", "ğŸŒ", "ğŸŒ", "ğŸŒ", "ğŸŒ", "ğŸŒ‘", "ğŸŒ’", "ğŸŒ“", "ğŸŒ”", "ğŸŒ•", "ğŸŒ–", "ğŸŒ—", "ğŸŒ˜", "ğŸŒ™", "ğŸŒš", "ğŸŒ›", "ğŸŒœ", "ğŸŒ¡ï¸", "â˜€ï¸", "ğŸŒ", "ğŸŒ", "â­", "ğŸŒŸ", "ğŸŒ ",
            "â˜ï¸", "â›…", "â›ˆï¸", "ğŸŒ¤ï¸", "ğŸŒ¥ï¸", "ğŸŒ¦ï¸", "ğŸŒ§ï¸", "ğŸŒ¨ï¸", "ğŸŒ©ï¸", "ğŸŒªï¸", "ğŸŒ«ï¸", "ğŸŒ¬ï¸", "ğŸŒ€", "ğŸ’§", "ğŸ’¦", "ğŸ«§",
            "â˜‚ï¸", "â˜”", "â›±ï¸", "âš¡", "â„ï¸", "â˜ƒï¸", "â›„", "â˜„ï¸", "ğŸ”¥", "ğŸ©¸", "ğŸ‚", "ğŸ", "ğŸ„", "ğŸŒ°", "ğŸŒ±", "ğŸŒ²", "ğŸŒ³", "ğŸŒ´", "ğŸŒµ", "ğŸŒ¶ï¸", "ğŸŒ·", "ğŸŒ¸", "ğŸŒ¹", "ğŸŒº", "ğŸŒ»", "ğŸŒ¼", "ğŸŒ¾", "ğŸŒ¿", "ğŸ€", "ğŸ", "ğŸ‹", "ğŸƒ",
            "ğŸƒ", "ğŸ„", "ğŸ†", "ğŸ‡", "ğŸ§¨", "âœ¨", "ğŸˆ", "ğŸ‰", "ğŸŠ", "ğŸ‹", "ğŸŒ", "ğŸ", "ğŸ", "ğŸ", "ğŸ", "ğŸ‘", "ğŸ§§", "ğŸ€", "ğŸ", "ğŸ—ï¸", "ğŸŸï¸", "ğŸ«", "ğŸ–ï¸", "ğŸ†", "ğŸ…", "ğŸ¥‡", "ğŸ¥ˆ", "ğŸ¥‰",
            "âš½", "âš¾", "ğŸ¥", "ğŸ€", "ğŸ", "ğŸˆ", "ğŸ‰", "ğŸ¾", "ğŸ¸", "ğŸ¥", "ğŸ³", "ğŸ", "ğŸ‘", "ğŸ’", "ğŸ¥", "ğŸ“", "â›³", "ğŸª", "ğŸ¹", "ğŸ£", "ğŸ¤¿", "ğŸ¥Š", "ğŸ¥‹", "ğŸ½", "ğŸ›¹", "ğŸ›¼", "ğŸ›·", "â›¸ï¸", "ğŸ¥Œ", "ğŸ¿",
            "ğŸ¯", "ğŸ±", "ğŸ”®", "ğŸª„", "ğŸ§¿", "ğŸ®", "ğŸ•¹ï¸", "ğŸ°", "ğŸ²", "ğŸ§©", "ğŸ§¸", "ğŸª…", "ğŸª†", "ğŸ–¼ï¸", "ğŸ¨", "ğŸ§µ", "ğŸª¡", "ğŸ§¶", "ğŸª¢",
            "ğŸ‘“", "ğŸ•¶ï¸", "ğŸ¥½", "ğŸ¥¼", "ğŸ¦º", "ğŸ‘”", "ğŸ‘•", "ğŸ‘–", "ğŸ§£", "ğŸ§¤", "ğŸ§¥", "ğŸ§¦", "ğŸ‘—", "ğŸ‘˜", "ğŸ¥»", "ğŸ©±", "ğŸ©²", "ğŸ©³", "ğŸ‘™", "ğŸ‘š", "ğŸ‘›", "ğŸ‘œ", "ğŸ‘", "ğŸ’", "ğŸ‘", "ğŸ‘Ÿ", "ğŸ¥¾", "ğŸ¥¿", "ğŸ‘ ", "ğŸ‘¡", "ğŸ©°", "ğŸ‘¢",
            "ğŸ‘‘", "ğŸ‘’", "ğŸ©", "ğŸ“", "ğŸ§¢", "â›‘ï¸", "ğŸ’„", "ğŸ’", "ğŸ’¼"
        ),
        "Transport & Map" to listOf( // U+1F680 - U+1F6FF
            "ğŸš€", "ğŸš", "ğŸš‚", "ğŸšƒ", "ğŸš„", "ğŸš…", "ğŸš†", "ğŸš‡", "ğŸšˆ", "ğŸš‰", "ğŸšŠ", "ğŸš‹", "ğŸšŒ", "ğŸš", "ğŸš", "ğŸš", "ğŸš", "ğŸš‘", "ğŸš’", "ğŸš“", "ğŸš”", "ğŸš•", "ğŸš–", "ğŸš—", "ğŸš˜", "ğŸš™", "ğŸ›»", "ğŸšš", "ğŸš›", "ğŸšœ",
            "ğŸï¸", "ğŸï¸", "ğŸ›µ", "ğŸ¦½", "ğŸ¦¼", "ğŸ›º", "ğŸš²", "ğŸ›´", "ğŸ›¹", "ğŸ›¼", "ğŸ›°ï¸", "ğŸ›¸", "ğŸ›¶", "â›µ", "ğŸš¤", "ğŸ›¥ï¸", "ğŸ›³ï¸", "â›´ï¸", "ğŸš¢", "âœˆï¸", "ğŸ›©ï¸", "ğŸ›«", "ğŸ›¬", "ğŸª‚", "ğŸ’º",
            "â›½", "ğŸš§", "ğŸš¦", "ğŸš¥", "ğŸ›‘", "ğŸ", "ğŸš©", "ğŸŒ", "ğŸ´", "ğŸ³ï¸", "ğŸ³ï¸â€ğŸŒˆ", "ğŸ³ï¸â€âš§ï¸", "âš“", "ğŸ—ºï¸", "ğŸ§­"
        ),
        "Misc Symbols" to listOf( // U+2600 - U+26FF
            "â˜€", "â˜", "â˜‚", "â˜ƒ", "â˜„", "â˜…", "â˜†", "â˜‡", "â˜ˆ", "â˜‰", "â˜Š", "â˜‹", "â˜Œ", "â˜", "â˜", "â˜", "â˜", "â˜‘", "â˜’", "â˜“", "â˜”", "â˜•", "â˜˜ï¸", "â˜ ï¸", "â˜¢ï¸", "â˜£ï¸", "â˜¦ï¸", "â˜ªï¸", "â˜®ï¸", "â˜¯ï¸", "â˜¸ï¸", "â˜¹ï¸", "â˜ºï¸",
            "â™€ï¸", "â™‚ï¸", "â™ˆ", "â™‰", "â™Š", "â™‹", "â™Œ", "â™", "â™", "â™", "â™", "â™‘", "â™’", "â™“", "â™Ÿï¸", "â™ ï¸", "â™£ï¸", "â™¥ï¸", "â™¦ï¸", "â™¨ï¸", "â™»ï¸", "â™¾ï¸", "â™¿", "âš’ï¸", "âš“", "âš”ï¸", "âš•ï¸", "âš–ï¸", "âš—ï¸", "âš™ï¸", "âš›ï¸", "âšœï¸",
            "âš ï¸", "âš¡", "âšª", "âš«", "âš½", "âš¾", "â›„", "â›…", "â›ˆï¸", "â›", "â›ï¸", "â›‘ï¸", "â›“ï¸", "â›”", "â›©ï¸", "â›ª", "â›°ï¸", "â›±ï¸", "â›²", "â›³", "â›´ï¸", "â›µ", "â›·ï¸", "â›¸ï¸", "â›¹ï¸â€â™€ï¸", "â›¹ï¸", "â›¹ï¸â€â™‚ï¸", "â›º", "â›½"
        ),
        "Dingbats" to listOf( // U+2700 - U+27BF
            "âœ€", "âœ", "âœ‚", "âœƒ", "âœ„", "âœ…", "âœ†", "âœ‡", "âœˆ", "âœ‰", "âœŠ", "âœ‹", "âœŒ", "âœ", "âœ", "âœ", "âœ", "âœ‘", "âœ’", "âœ”", "âœ•", "âœ–", "âœ—", "âœ˜", "âœ™", "âœš", "âœ›", "âœœ", "âœï¸", "âœ", "âœŸ", "âœ ", "âœ¡ï¸", "â˜¸ï¸",
            "âœï¸", "âœŒï¸", "â˜ï¸", "ğŸ––", "ğŸ–ï¸", "ğŸ–•", "ğŸ¤³", "ğŸ’…", "ğŸ‘„", "ğŸ¦·", "ğŸ‘…", "ğŸ‘‚", "ğŸ‘ƒ", "ğŸ‘ï¸", "ğŸ‘€", "ğŸ§ ", "ğŸ¦´", "ğŸ—£ï¸", "ğŸ‘¤", "ğŸ‘¥", "ğŸ«‚"
        ),
        "Supplemental Symbols" to listOf( // U+1F900 - U+1F9FF
            "ğŸ¤°", "ğŸ¤±", "ğŸ¤²", "ğŸ§ ", "ğŸ§¡", "ğŸ§¢", "ğŸ§£", "ğŸ§¤", "ğŸ§¥", "ğŸ§¦", "ğŸ§§", "ğŸ§¨", "ğŸ§©", "ğŸ§ª", "ğŸ§«", "ğŸ§¬", "ğŸ§­", "ğŸ§®", "ğŸ§¯", "ğŸ§°", "ğŸ§±",
            "ğŸª‘", "ğŸª’", "ğŸª“", "ğŸª”", "ğŸª•", "ğŸª–", "ğŸª—", "ğŸª˜", "ğŸª™", "ğŸªš", "ğŸª›", "ğŸªœ", "ğŸª", "ğŸª", "ğŸªŸ", "ğŸª ", "ğŸª¤", "ğŸª£", "ğŸª¥", "ğŸª¦", "ğŸª§", "ğŸª¨", "ğŸªµ", "ğŸ›–",
            "ğŸª±", "ğŸª°", "ğŸª²", "ğŸª³", "ğŸª´", "ğŸª¶", "ğŸ¦°", "ğŸ¦±", "ğŸ¦²", "ğŸ¦³", "ğŸ¦´", "ğŸ¦µ", "ğŸ¦¶", "ğŸ¦·", "ğŸ¦¸", "ğŸ¦¹", "ğŸ¦º", "ğŸ¦»", "ğŸ¦¼", "ğŸ¦½", "ğŸ¦¾", "ğŸ¦¿",
            "ğŸ§€", "ğŸ§", "ğŸ§‚", "ğŸ¥£", "ğŸ¥¤", "ğŸ¥¥", "ğŸ¥¦", "ğŸ¥­", "ğŸ¥®", "ğŸ¥¯", "ğŸ¥°", "ğŸ¥±", "ğŸ¥²", "ğŸ¥¸", "ğŸ¥³", "ğŸ¥´", "ğŸ¥µ", "ğŸ¥¶", "ğŸ¥º", "ğŸ¥»", "ğŸ¥¼", "ğŸ¥½", "ğŸ¥¾", "ğŸ¥¿"
        ),
        "Symbols Extended-A" to listOf( // U+1FA70 - U+1FAFF
            "ğŸª€", "ğŸª", "ğŸª‚", "ğŸªƒ", "ğŸª„", "ğŸª…", "ğŸª†", "ğŸª", "ğŸª‘", "ğŸª’", "ğŸª“", "ğŸª”", "ğŸª•", "ğŸª–", "ğŸª—", "ğŸª˜", "ğŸª™", "ğŸªš", "ğŸª›", "ğŸªœ", "ğŸª", "ğŸª", "ğŸªŸ", "ğŸª ", "ğŸª¤", "ğŸª£", "ğŸª¥", "ğŸª¦", "ğŸª§", "ğŸª¨",
            "ğŸªµ", "ğŸ›–", "ğŸª±", "ğŸª°", "ğŸª²", "ğŸª³", "ğŸª´", "ğŸª¶", "ğŸ«€", "ğŸ«", "ğŸ«‚", "ğŸ«ƒ", "ğŸ«„", "ğŸ«…", "ğŸ«–", "ğŸ«—", "ğŸ«˜", "ğŸ«™", "ğŸ«š", "ğŸ«›", "ğŸ«œ", "ğŸ«", "ğŸ«", "ğŸ«Ÿ", "ğŸ« ", "ğŸ«¡"
        )
        // Regional Indicator Symbols (flags) are omitted for now due to complexity and number.
    )

    // Constants for emoji grid layout
    private val EMOJI_COLUMNS = 8 // Number of emojis per row in the grid
    private val EMOJI_ROWS = 4    // Number of emoji rows to display per page/category view

    // Keyboard colors
    private var keyBackgroundColor = 0
    private var keyTextColor = 0
    private var mIsDarkMode = false
    private var specialKeyBackgroundColor = 0
    private var keyboardBackgroundColor = 0
    
    // Shared preferences for settings
    private lateinit var preferences: SharedPreferences

    // Turbo delete variables
    private val deleteHandler = Handler(Looper.getMainLooper())
    private lateinit var deleteRunnable: Runnable
    private var isDeleting = false
    private var deleteCount = 0
    private val initialDeleteDelay = 500L // ms before starting repeat
    private val repeatDeleteDelay = 80L // ms between deletes in normal mode
    private val turboDeleteDelay = 30L // ms between deletes in turbo mode
    private val maxDeletesBeforeTurbo = 8 // number of deletes before switching to turbo speed
    private val wordDeleteDelay = 3000L // 3 seconds to hold for word delete
    private var wordDeleteRunnable: Runnable? = null
    private var isWordDeleteActive = false
    private var isTextOrSearchField: Boolean = false // Added for spacebar swipe logic
    private var currentEditorAction: Int = EditorInfo.IME_ACTION_NONE
    private var currentInputTypeSupportsMultiLine: Boolean = false
    private var currentInputEditorInfo: EditorInfo? = null
    
    // Key popup
    private var keyPopup: PopupWindow? = null
    private var currentPopupKey: View? = null

    override fun onCreate() {
        super.onCreate()
        Log.d(TAG, "RewordiumAIKeyboardService created")
        
        // Initialize preferences
        preferences = getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
        
        // Load settings
        loadSettings()
    }
    
    /**
     * Loads user settings from SharedPreferences
     */
    private fun loadSettings() {
        themeColor = preferences.getString(KEY_THEME_COLOR, "#007AFF") ?: "#007AFF"
        isDarkMode = preferences.getBoolean(KEY_DARK_MODE, false)
        isHapticFeedbackEnabled = preferences.getBoolean(KEY_HAPTIC_FEEDBACK, true)
        isAutoCapitalizeEnabled = preferences.getBoolean(KEY_AUTO_CAPITALIZE, true)
        isDoubleSpacePeriodEnabled = preferences.getBoolean(KEY_DOUBLE_SPACE_PERIOD, true)
        
        // Update colors based on settings
        updateColors()
    }
    
    /**
     * Updates color scheme based on current settings
     */
    private fun updateColors() {
        try {
            val themeColorInt = Color.parseColor(themeColor)
            
            if (isDarkMode) {
                // Dark mode colors
                keyBackgroundColor = Color.parseColor("#333333")
                keyTextColor = Color.WHITE
                specialKeyBackgroundColor = Color.parseColor("#333333")
                keyboardBackgroundColor = Color.parseColor("#1C1C1E")
            } else {
                // Light mode colors (iOS style)
                keyBackgroundColor = Color.parseColor("#FFFFFF")
                keyTextColor = Color.BLACK
                specialKeyBackgroundColor = Color.parseColor("#D1D1D6")
                keyboardBackgroundColor = Color.parseColor("#D1D1D6")
            }
            
            // Apply the colors immediately if we have a view
            if (inputView != null) {
                Handler(Looper.getMainLooper()).post {
                    applyThemeColors()
                }
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error updating colors: ${e.message}")
            e.printStackTrace()
        }
    }
    
    /**
     * Updates the AI button colors based on the current theme
     */
    private fun setupAIButton() {
        try {
            val aiButton = inputView?.findViewById<android.widget.FrameLayout>(R.id.ai_button) ?: return
            val gifView = inputView?.findViewById<pl.droidsonroids.gif.GifImageView>(R.id.ai_animation) ?: return
            
            // Store reference to gifView for later use
            this.gifView = gifView
            
            // Set up the GIF view
            try {
                // The GIF is already set in the XML layout using android:src
                // Just make sure it's set to loop and has transparent background
                gifView.setBackgroundColor(Color.TRANSPARENT)
                
                // Track initial touch coordinates
                val touchSlop = ViewConfiguration.get(applicationContext).scaledTouchSlop
                var touchDownX = 0f
                var touchDownY = 0f
                
                // Set up touch listener on the parent to handle haptics and animation
                aiButton.setOnTouchListener { v, event ->
                    when (event.action) {
                        MotionEvent.ACTION_DOWN -> {
                            // Store initial touch coordinates
                            touchDownX = event.rawX
                            touchDownY = event.rawY
                            // Visual feedback
                            v.alpha = 0.7f
                            true
                        }
                        MotionEvent.ACTION_UP -> {
                            v.alpha = 1.0f
                            
                            // Only trigger action if user didn't move their finger too much
                            if (Math.abs(event.rawX - touchDownX) < touchSlop.toFloat() && 
                                Math.abs(event.rawY - touchDownY) < touchSlop.toFloat()) {
                                // Handle AI button click
                                Log.d(TAG, "AI button clicked")
                                
                                // Restart the animation
                                val gifDrawable = gifView.drawable as? pl.droidsonroids.gif.GifDrawable
                                gifDrawable?.seekTo(0)
                                gifDrawable?.start()
                                
                                // Trigger haptic feedback if enabled
                                if (isHapticFeedbackEnabled) {
                                    performHapticFeedback()
                                }
                                
                                // Handle AI button action
                                handleAIButton()
                            }
                            true
                        }
                        MotionEvent.ACTION_CANCEL -> {
                            v.alpha = 1.0f
                            true
                        }
                        else -> false
                    }
                }
                
            } catch (e: Exception) {
                Log.e(TAG, "Error setting up GIF: ${e.message}")
            }
            
            // Set click listener for AI button
            aiButton.setOnClickListener {
                try {
                    // Handle AI button click
                    Log.d(TAG, "AI button clicked")
                    
                    // Restart the animation
                    gifView?.let { gif ->
                        val gifDrawable = gif.drawable as? pl.droidsonroids.gif.GifDrawable
                        gifDrawable?.seekTo(0)
                        gifDrawable?.start()
                    }
                    
                    // Trigger haptic feedback if enabled
                    if (isHapticFeedbackEnabled) {
                        performHapticFeedback()
                    }
                    
                    // Handle AI button action
                    handleAIButton()
                    
                } catch (e: Exception) {
                    Log.e(TAG, "Error in AI button click: ${e.message}")
                }
            }
            
        } catch (e: Exception) {
            Log.e(TAG, "Error setting up AI button: ${e.message}")
            e.printStackTrace()
        }
    }
    
    override fun onCreateInputView(): View {
        Log.d(TAG, "Creating input view")
        try {
            inputView = LayoutInflater.from(this).inflate(R.layout.ios_keyboard_layout, null)
            keyboardContainer = inputView?.findViewById(R.id.keyboard_container) ?: throw IllegalStateException("Keyboard container not found")
            
            // Initialize keyboard rows first
            numberRow = inputView?.findViewById(R.id.number_row) ?: throw IllegalStateException("Number row not found")
            rowQwerty = inputView?.findViewById(R.id.row_qwerty) ?: throw IllegalStateException("QWERTY row not found")
            rowAsdf = inputView?.findViewById(R.id.row_asdfghjkl) ?: throw IllegalStateException("ASDF row not found")
            rowZxcv = inputView?.findViewById(R.id.row_zxcvbnm) ?: throw IllegalStateException("ZXCV row not found")
            bottomRow = inputView?.findViewById(R.id.bottom_row) ?: throw IllegalStateException("Bottom row not found")
            
            // Initialize suggestion bar
            initSuggestionBar()
            
            // Initialize paraphrase view
            initParaphraseView()
            
            // Initialize keyboard buttons
            setupKeyboardButtons()
            
            // Apply theme colors
            applyThemeColors()
            
            // Setup keyboard layout
            setupKeyboard()
            
            return inputView!!
        } catch (e: Exception) {
            Log.e(TAG, "Error creating input view: ${e.message}")
            e.printStackTrace()
            // Return a simple view to prevent crashes
            return TextView(this).apply {
                text = "Error loading keyboard"
                gravity = Gravity.CENTER
                setTextColor(Color.BLACK)
                setBackgroundColor(Color.WHITE)
            }
        }
    }
    
    /**
     * Initializes the suggestion bar components
     */
    private fun initSuggestionBar() {
        try {
            suggestionContainer = inputView?.findViewById(R.id.suggestion_container) 
                ?: throw IllegalStateException("Suggestion container not found")
            
            // Initialize the single text view for all suggestions
            suggestionsTextView = inputView?.findViewById(R.id.suggestions_text)
                ?: throw IllegalStateException("Suggestions text view not found")
            
            // Set text color based on theme
            suggestionsTextView.setTextColor(Color.parseColor("#007AFF")) // iOS blue
            
            // Set click listener for the suggestions text view
            setupSuggestionClicks()
            
            // Initially hide suggestions
            updateSuggestions(emptyList())
        } catch (e: Exception) {
            Log.e(TAG, "Error initializing suggestion bar: ${e.message}")
            // If we can't initialize the suggestion bar, make sure we don't crash
            suggestionContainer.visibility = View.GONE
            throw e
        }
    }
    
    private fun setupSuggestionClicks() {
        // Set up touch listener for the entire suggestions text view
        suggestionsTextView.setOnTouchListener { view, event ->
            when (event.action) {
                MotionEvent.ACTION_DOWN -> {
                    val x = event.x
                    val viewWidth = view.width.toFloat()
                    
                    // Divide the suggestion bar into 3 equal parts
                    val partWidth = viewWidth / 3
                    
                    // Determine which part was tapped (0, 1, or 2)
                    val partIndex = (x / partWidth).toInt().coerceIn(0, 2)
                    
                    // If we have a suggestion at this position, select it
                    if (partIndex < currentSuggestions.size) {
                        onSuggestionTapped(currentSuggestions[partIndex])
                        return@setOnTouchListener true
                    }
                }
            }
            false
        }
    }
    
    /**
     * Handles clicks on the suggestion text view
     */
    private fun onSuggestionTapped(suggestion: String) {
        // Only commit the tapped suggestion if it's not empty
        if (suggestion.isNotEmpty()) {
            val ic = currentInputConnection ?: return
            
            // Handle differently based on whether we're in paraphrasing mode
            if (isParaphrasingMode) {
                // Get the text before cursor to replace the current sentence
                val textBeforeCursor = ic.getTextBeforeCursor(1000, 0)?.toString() ?: ""
                
                if (currentSentenceStart >= 0 && currentSentenceStart < textBeforeCursor.length) {
                    // Delete the current sentence
                    val deleteLength = textBeforeCursor.length - currentSentenceStart
                    ic.deleteSurroundingText(deleteLength, 0)
                    
                    // Insert the selected paraphrase
                    ic.commitText(suggestion, 1)
                    
                    // Reset paraphrasing mode
                    isParaphrasingMode = false
                    currentSentenceStart = 0
                }
            } else {
                // Regular word suggestion mode
                // Get the text before the cursor
                val textBeforeCursor = ic.getTextBeforeCursor(100, 0)?.toString() ?: ""
                
                // Find the start of the current word
                val wordStart = textBeforeCursor.takeLastWhile { it.isLetterOrDigit() || it == '\'' }.length
                
                // Delete the current word if there is one
                if (wordStart > 0) {
                    ic.deleteSurroundingText(wordStart, 0)
                }
                
                // Insert the selected suggestion with a space
                ic.commitText("$suggestion ", 1)
                
                // Clear the current word buffer
                currentWord = ""
            }
            
            // Clear suggestions after selection
            updateSuggestions(emptyList())
            
            // Trigger haptic feedback if enabled
            if (isHapticFeedbackEnabled) {
                performHapticFeedback()
            }
            
            try {
                // No-op, just to keep the try-catch structure
            } catch (e: Exception) {
                Log.e(TAG, "Error committing text: ${e.message}")
            }
        }
    }
    
    /**
     * Updates the suggestion bar with new suggestions
     */
    private fun updateSuggestions(suggestions: List<String>) {
        currentSuggestions = suggestions.take(3) // Only take first 3 suggestions
        
        if (currentSuggestions.isEmpty()) {
            suggestionsTextView.visibility = View.GONE
            return
        }
        
        // Reset text size to default before measuring
        val defaultTextSize = 16f // Default size in SP
        suggestionsTextView.textSize = defaultTextSize
        
        // Get display metrics
        val displayMetrics = resources.displayMetrics
        val screenWidth = displayMetrics.widthPixels.toFloat()
        val partWidth = screenWidth / 5
        val divider = " | "
        val dividerWidth = suggestionsTextView.paint.measureText(divider)
        
        // Create a list to hold the formatted suggestions
        val formattedSuggestions = mutableListOf<String>()
        
        // Process each suggestion to ensure it fits in its part
        currentSuggestions.forEachIndexed { index, suggestion ->
            val paint = suggestionsTextView.paint
            var currentSuggestion = suggestion
            
            // Calculate maximum width for this suggestion (part width minus half of divider on each side)
            val maxSuggestionWidth = partWidth - dividerWidth
            
            // Measure the text width
            var textWidth = paint.measureText(currentSuggestion)
            
            // If text is too wide, try to fit it
            if (textWidth > maxSuggestionWidth) {
                // First try to reduce the text size
                val scale = (maxSuggestionWidth / textWidth) * 0.95f // 95% to be safe
                val newSize = defaultTextSize * scale
                
                if (newSize >= 10f) { // Don't go below 10sp
                    paint.textSize = newSize * displayMetrics.scaledDensity
                    textWidth = paint.measureText(currentSuggestion)
                    
                    // If still too wide, truncate with ellipsis
                    if (textWidth > maxSuggestionWidth) {
                        currentSuggestion = truncateTextWithEllipsis(
                            paint, 
                            currentSuggestion, 
                            maxSuggestionWidth
                        )
                    }
                } else {
                    // Text is still too wide, force truncation
                    currentSuggestion = truncateTextWithEllipsis(
                        paint, 
                        currentSuggestion, 
                        maxSuggestionWidth
                    )
                }
                
                // Reset paint text size
                paint.textSize = defaultTextSize * displayMetrics.scaledDensity
            }
            
            // Center the text in its part
            val padding = (partWidth - paint.measureText(currentSuggestion)) / 2
            val space = " ".repeat((padding / paint.measureText(" ")).toInt())
            formattedSuggestions.add("$space$currentSuggestion$space")
        }
        
        // Ensure we have exactly 3 parts (even if some are empty)
        while (formattedSuggestions.size < 3) {
            formattedSuggestions.add("")
        }
        
        // Join with dividers and set the text
        val suggestionsText = "${formattedSuggestions[0]} | ${formattedSuggestions[1]} | ${formattedSuggestions[2]}"
        
        // Set the text and make visible
        suggestionsTextView.text = suggestionsText.trim()
        suggestionsTextView.visibility = View.VISIBLE
        suggestionsTextView.gravity = Gravity.CENTER
    }
    
    private fun truncateTextWithEllipsis(paint: TextPaint, text: String, maxWidth: Float): String {
        if (paint.measureText(text) <= maxWidth) return text
        
        val ellipsis = "..."
        val ellipsisWidth = paint.measureText(ellipsis)
        val availableWidth = maxWidth - ellipsisWidth.toFloat()
        
        var left = 0
        var right = text.length
        var mid: Int
        
        // Binary search for the maximum length that fits
        while (left < right) {
            mid = (left + right) / 2
            val width = paint.measureText(text, 0, mid)
            
            if (width < availableWidth) {
                left = mid + 1
            } else {
                right = mid - 1
            }
        }
        
        // Ensure we don't go out of bounds
        val end = (left - 1).coerceAtLeast(0)
        return "${text.substring(0, end)}$ellipsis"
    }
    
    private fun generateSuggestions(text: String): List<String> {
        if (text.isEmpty()) return emptyList()
        
        // Get the current word being typed (last word in the text)
        val currentWord = text.split("\\s").lastOrNull()?.lowercase() ?: return emptyList()
        
        // Get suggestions from our dictionary
        return SuggestionDictionary.getSuggestions(currentWord, this@RewordiumAIKeyboardService)
    }
    
    /**
     * Updates suggestions based on current input
     */
    private fun updateSuggestionsFromInput() {
        val ic = currentInputConnection ?: return
        
        // Get text before cursor
        val textBeforeCursor = ic.getTextBeforeCursor(100, 0)?.toString() ?: ""
        val textAfterCursor = ic.getTextAfterCursor(100, 0)?.toString() ?: ""
        
        // Only update if text has changed
        if (textBeforeCursor == lastInputText && textAfterCursor.isEmpty()) return
        
        lastInputText = textBeforeCursor
        
        // Get current word
        val currentWord = textBeforeCursor.split("\\s").lastOrNull() ?: ""
        
        // Generate and update suggestions
        val suggestions = generateSuggestions(currentWord)
        updateSuggestions(suggestions)
    }
    
    private fun applyThemeColors() {
        try {
            // Get the root layout
            val rootLayout = inputView?.findViewById<View>(R.id.root_keyboard_layout)
            
            // Set root layout background color based on theme
            val bgColor = if (isDarkMode) {
                Color.parseColor("#1C1C1E") // Dark background
            } else {
                Color.parseColor("#D1D1D6") // Light background (matching iOS style)
            }
            
            // Apply colors to all relevant views
            rootLayout?.setBackgroundColor(bgColor)
            keyboardContainer?.setBackgroundColor(bgColor)
            
            // Update top bar background color
            val topBar = inputView?.findViewById<View>(R.id.top_bar_container)
            topBar?.setBackgroundColor(bgColor)
            
            // Update suggestion container background
            suggestionContainer?.setBackgroundColor(Color.TRANSPARENT)
            
            // Force update suggestion view if initialized
            if (::suggestionsTextView.isInitialized) {
                // Ensure text color is always iOS blue
                suggestionsTextView.setTextColor(Color.parseColor("#007AFF"))
                
                // Force redraw the suggestion container
                suggestionsTextView.invalidate()
                suggestionsTextView.requestLayout()
            }
            
            // Update keyboard container padding area
            keyboardContainer?.setPaddingRelative(
                keyboardContainer?.paddingStart ?: 0,
                keyboardContainer?.paddingTop ?: 0,
                keyboardContainer?.paddingEnd ?: 0,
                keyboardContainer?.paddingBottom ?: 0
            )
            
            // Set up AI button with current theme
            setupAIButton()
            
        } catch (e: Exception) {
            Log.e(TAG, "Error applying theme colors: ${e.message}")
            e.printStackTrace()
        }
    }
    
    /**
     * Handles text input with support for double-space for period functionality
     */
    private fun handleText(text: String, enableHaptic: Boolean = true) {
        val ic = currentInputConnection ?: return
        
        // Update suggestions after text input
        Handler(Looper.getMainLooper()).postDelayed({
            updateSuggestionsFromInput()
        }, 50) // Small delay to ensure text is committed
        
        // Handle double-space for period if enabled
        if (isDoubleSpacePeriodEnabled && text == " ") {
            val currentTime = System.currentTimeMillis()
            
            // Check if this is a double-space (within 500ms of previous space)
            if (currentTime - lastSpaceTime < 500 && lastKeyWasSpace) {
                // Delete the previous space
                ic.deleteSurroundingText(1, 0)
                // Add period + space
                ic.commitText(". ", 1)
                
                // Clear suggestions after period
                updateSuggestions(emptyList())
                
                // Provide haptic feedback for the second space tap if enabled
                if (isHapticFeedbackEnabled && enableHaptic) {
                    performHapticFeedback()
                }

                // Enable caps for next character
                if (isAutoCapitalizeEnabled) {
                    isCapsOn = true
                    setupKeyboard()
                }
                
                lastKeyWasSpace = false
                lastSpaceTime = 0 // Reset the timer
                return
            }
            
            lastKeyWasSpace = true
            lastSpaceTime = currentTime
        } else {
            // Reset the space timer for any non-space character
            lastKeyWasSpace = false
            lastSpaceTime = 0
            
            // Auto-capitalize after sentence endings if enabled
            if (isAutoCapitalizeEnabled && text in listOf(".", "!", "?")) {
                isCapsOn = true
                setupKeyboard()
            }
        }
        
        // Commit the text
        ic.commitText(text, 1)
        
        // Turn off shift (but not caps lock) after typing a character or space
        if (isCapsOn && !isCapsLock && text != "") {
            isCapsOn = false
            setupKeyboard()
        }
        
        // Provide haptic feedback if enabled
        if (isHapticFeedbackEnabled && enableHaptic) {
            performHapticFeedback()
        }
    }
    
    /**
     * Performs haptic feedback for key presses
     */
    private fun performHapticFeedback() {
        try {
            // Try to use view haptic feedback first
            inputView?.performHapticFeedback(
                HapticFeedbackConstants.KEYBOARD_TAP,
                HapticFeedbackConstants.FLAG_IGNORE_GLOBAL_SETTING
            )
        } catch (e: Exception) {
            // Fall back to vibrator service
            try {
                val vibrator = getSystemService(Context.VIBRATOR_SERVICE) as? Vibrator
                vibrator?.let {
                    if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.O) {
                        it.vibrate(VibrationEffect.createOneShot(10, VibrationEffect.DEFAULT_AMPLITUDE))
                    } else {
                        @Suppress("DEPRECATION")
                        it.vibrate(10)
                    }
                }
            } catch (e: Exception) {
                Log.e(TAG, "Error performing haptic feedback: ${e.message}")
            }
        }
    }
    
    private fun setupKeyboardButtons() {
        try {
            // Set up AI button with WebM animation
            setupAIButton()
        } catch (e: Exception) {
            Log.e(TAG, "Error setting up AI button: ${e.message}")
            e.printStackTrace()
        }
        
        // Rows are now initialized in onCreateInputView
        if (numberRow == null || rowQwerty == null || rowAsdf == null || rowZxcv == null || bottomRow == null) {
            Log.e(TAG, "Keyboard rows not properly initialized")
            throw IllegalStateException("Keyboard rows not properly initialized")
        }
    }
    
    /**
     * Sets up the keyboard layout based on current state
     */
    private fun setupKeyboard() {
        try {
            Log.d(TAG, "setupKeyboard called. States: isEmojiKeyboardShown=$isEmojiKeyboardShown, isSymbolsShown=$isSymbolsShown, isCapsOn=$isCapsOn, isCapsLock=$isCapsLock")
            
            // Check if rows are properly initialized
            if (numberRow == null || rowQwerty == null || rowAsdf == null || rowZxcv == null || bottomRow == null) {
                Log.e(TAG, "Keyboard rows not initialized, initializing now")
                setupKeyboardButtons()
                if (numberRow == null || rowQwerty == null || rowAsdf == null || rowZxcv == null || bottomRow == null) {
                    throw IllegalStateException("Failed to initialize keyboard rows")
                }
            }
            
            // Clear existing views
            numberRow.removeAllViews()
            rowQwerty.removeAllViews()
            rowAsdf.removeAllViews()
            rowZxcv.removeAllViews()
            bottomRow.removeAllViews()
        } catch (e: Exception) {
            Log.e(TAG, "Error in setupKeyboard: ${e.message}")
            e.printStackTrace()
            throw e
        }
        
        when {
            isEmojiKeyboardShown -> setupEmojiKeyboard()
            isSymbolsShown -> setupSymbolsKeyboard()
            else -> setupLettersKeyboard()
        }
    }
    
    private fun setupLettersKeyboard() {
        Log.d(TAG, "setupLettersKeyboard called. States: isCapsOn=$isCapsOn, isCapsLock=$isCapsLock")
        
        // Update keyboard state
        keyboardState = KeyboardState.LETTERS
        
        // Show letter keyboard components
        numberRow.visibility = View.VISIBLE
        rowQwerty.visibility = View.VISIBLE
        rowAsdf.visibility = View.VISIBLE
        rowZxcv.visibility = View.VISIBLE
        bottomRow.visibility = View.VISIBLE
        
        // Hide other keyboard layouts
        if (::symbolsKeyboardContainer.isInitialized) {
            symbolsKeyboardContainer.visibility = View.GONE
        }
        if (::emojiKeyboardContainer.isInitialized) {
            emojiKeyboardContainer.visibility = View.GONE
        }
        // Add number row
        for (char in "1234567890") {
            addKey(numberRow, char.toString()) { handleText(char.toString()) }
        }
        
        // Add QWERTY row
        val qwertyRow = if (isCapsOn) "QWERTYUIOP" else "qwertyuiop"
        for (char in qwertyRow) {
            addKey(rowQwerty, char.toString()) { handleText(char.toString()) }
        }
        
        // Add left padding to ASDF row without creating an actual key
        val leftPadding = View(this)
        val paddingParams = LinearLayout.LayoutParams(
            0, 
            resources.getDimensionPixelSize(R.dimen.ios_key_height),
            0.5f
        )
        rowAsdf.addView(leftPadding, paddingParams)
        
        val asdfRow = if (isCapsOn) "ASDFGHJKL" else "asdfghjkl"
        for (char in asdfRow) {
            addKey(rowAsdf, char.toString()) { handleText(char.toString()) }
        }
        
        // Add right padding after 'L' key
        val rightPadding = View(this)
        val rightPaddingParams = LinearLayout.LayoutParams(
            0, 
            resources.getDimensionPixelSize(R.dimen.ios_key_height),
            0.5f
        )
        rowAsdf.addView(rightPadding, rightPaddingParams)
        
        // No backspace key here anymore - moved to bottom row
        
        // Add ZXCV row
        // Add shift key
        val shiftIconRes = when {
            isCapsLock -> R.drawable.ic_shift_caps_lock  // Use special icon with underscore for caps lock
            isCapsOn -> R.drawable.ic_shift_filled      // Regular filled icon for shift
            else -> R.drawable.ic_shift                 // Outline icon for normal state
        }
        val shiftKey = addSpecialKey(rowZxcv, "", shiftIconRes, 2.0f) {
            toggleCapsLock()
        }
        
        // Apply special styling to shift key based on state
        // Create a custom drawable for the shift key that respects the theme
        val shiftDrawable = GradientDrawable().apply {
            cornerRadius = TypedValue.applyDimension(
                TypedValue.COMPLEX_UNIT_DIP,
                6f,
                resources.displayMetrics
            )
            // Set the default background color (will be overridden by state colors)
            setColor(if (isDarkMode) specialKeyBackgroundColor else keyBackgroundColor)
        }
        shiftKey.background = shiftDrawable
        // Ensure the shift key has proper padding like other keys
        shiftKey.setPadding(0, 10, 0, 0)
        
        // Set state for proper background color
        if (shiftKey is Button) {
            // Use tag to track state since isActivated/isChecked might not be available
            shiftKey.tag = if (isCapsLock) 2 else if (isCapsOn) 1 else 0
            
            // Apply different background tint based on state and dark mode
            val stateColor = when {
                isCapsLock -> Color.parseColor(themeColor) // Theme color for caps lock (same in both modes)
                isCapsOn -> if (isDarkMode) Color.parseColor("#555555") else Color.GRAY // Lighter gray in dark mode
                else -> if (isDarkMode) specialKeyBackgroundColor else keyBackgroundColor // Use theme colors for normal state
            }
            
            val drawable = shiftKey.background.mutate()
            DrawableCompat.setTint(drawable, stateColor)
            
            // Set icon color to white for caps lock mode and add indicator
            if (shiftKey is ImageButton) {
                if (isCapsLock) {
                    // Set icon to white for caps lock
                    shiftKey.colorFilter = PorterDuffColorFilter(Color.WHITE, PorterDuff.Mode.SRC_IN)
                    
                    // Add a visual indicator for caps lock (a small dot)
                    val capsLockIndicator = View(this)
                    val indicatorSize = resources.getDimensionPixelSize(R.dimen.caps_lock_indicator_size)
                    val params = FrameLayout.LayoutParams(indicatorSize, indicatorSize)
                    params.gravity = Gravity.TOP or Gravity.END
                    params.setMargins(0, 5, 5, 0)
                    
                    // Create a circular background
                    val indicatorDrawable = GradientDrawable().apply {
                        shape = GradientDrawable.OVAL
                        setColor(Color.WHITE)
                    }
                    capsLockIndicator.background = indicatorDrawable
                    
                    // First remove any existing indicator to avoid duplicates
                    // Cast to View first to resolve ambiguity
                    val shiftKeyView = shiftKey as View
                    if (shiftKeyView.parent is ViewGroup) {
                        val parent = shiftKeyView.parent as ViewGroup
                        for (i in 0 until parent.childCount) {
                            val child = parent.getChildAt(i)
                            if (child.tag == "caps_lock_indicator") {
                                parent.removeView(child)
                                break
                            }
                        }
                        
                        // Add the new indicator
                        capsLockIndicator.tag = "caps_lock_indicator"
                        parent.addView(capsLockIndicator, params)
                    }
                } else {
                    // Clear icon color for other states
                    shiftKey.clearColorFilter()
                    
                    // Remove the indicator if it exists
                    // Cast to View first to resolve ambiguity
                    val shiftKeyView = shiftKey as View
                    if (shiftKeyView.parent is ViewGroup) {
                        val parent = shiftKeyView.parent as ViewGroup
                        for (i in 0 until parent.childCount) {
                            val child = parent.getChildAt(i)
                            if (child.tag == "caps_lock_indicator") {
                                parent.removeView(child)
                                break
                            }
                        }
                    }
                }
            }
            
            // Increase text size for better visibility
            shiftKey.textSize = 30f
            shiftKey.typeface = android.graphics.Typeface.DEFAULT_BOLD
            shiftKey.setPadding(0, 10, 0, 0) // Better vertical centering
        }
        
        val zxcvRow = if (isCapsOn) "ZXCVBNM" else "zxcvbnm"
        for (char in zxcvRow) {
            addKey(rowZxcv, char.toString()) { handleText(char.toString()) }
        }
        
        // Add backspace key with turbo delete and word delete
        val backspaceKey = addSpecialKey(rowZxcv, "", R.drawable.ic_backspace, 1.5f) { /* onClick is overridden by setOnTouchListener */ }
        
        // Apply the same background as shift key
        val backspaceDrawable = GradientDrawable().apply {
            cornerRadius = TypedValue.applyDimension(
                TypedValue.COMPLEX_UNIT_DIP,
                6f,
                resources.displayMetrics
            )
            setColor(specialKeyBackgroundColor)
        }
        backspaceKey.background = backspaceDrawable
        if (backspaceKey is ImageButton) {
            backspaceKey.setPadding(0, 10, 0, 0)
        }
        
        backspaceKey.setOnTouchListener { v, event ->
            val ic = currentInputConnection ?: return@setOnTouchListener false
            
            when (event.action) {
                MotionEvent.ACTION_DOWN -> {
                    // Visual feedback
                    v.alpha = 0.7f
                    
                    // Start word delete timer
                    wordDeleteRunnable = Runnable {
                        isWordDeleteActive = true
                        // Strong haptic for word delete initiation
                        if (isHapticFeedbackEnabled) {
                            v.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS)
                        }
                        handleBackspace(ic, true)
                    }
                    deleteHandler.postDelayed(wordDeleteRunnable!!, wordDeleteDelay)
                    
                    // Initial delete
                    handleBackspace(ic)
                    
                    // Start turbo delete sequence
                    isDeleting = true
                    deleteCount = 0
                    
                    deleteRunnable = object : Runnable {
                        override fun run() {
                            if (isDeleting) {
                                handleBackspace(ic, isWordDeleteActive)
                                deleteCount++
                                val delay = if (deleteCount >= 5) 30L else repeatDeleteDelay // Turbo delete improved
                                deleteHandler.postDelayed(this, delay)
                            }
                        }
                    }
                    
                    // Start repeating deletes after initial delay
                    deleteHandler.postDelayed(deleteRunnable, initialDeleteDelay)
                    
                    true
                }
                
                MotionEvent.ACTION_UP, MotionEvent.ACTION_CANCEL -> {
                    // Clean up
                    isDeleting = false
                    isWordDeleteActive = false
                    wordDeleteRunnable?.let { deleteHandler.removeCallbacks(it) }
                    deleteHandler.removeCallbacks(deleteRunnable)
                    
                    // Reset visual state
                    v.alpha = 1.0f
                    // v.performClick() // Removed to prevent potential '?' issue
                    
                    true
                }
                
                else -> false
            }
        }
        
        // Add bottom row
        // Numbers key
        addSpecialKey(bottomRow, "123", null, 1.5f, true) {
            if (isHapticFeedbackEnabled) performHapticFeedback()
            isSymbolsShown = true
            setupKeyboard()
        }
        
        // Globe key (language)
        addSpecialKey(bottomRow, "", R.drawable.ic_globe, 1f) {
            // Would show language options
            Log.d(TAG, "Globe key pressed")
        }
        
        // Space bar with swipe navigation
        val spaceKey = addKey(bottomRow, "space", 0, 5f, false, true) {
            handleText(" ")
        }
        
        // Apply iOS-style appearance to spacebar
        if (spaceKey is Button) {
            // Create a custom drawable for the spacebar that respects the theme
            val spacebarDrawable = GradientDrawable().apply {
                cornerRadius = TypedValue.applyDimension(
                    TypedValue.COMPLEX_UNIT_DIP,
                    6f,
                    resources.displayMetrics
                )
                // Use the appropriate background color based on dark mode
                setColor(if (isDarkMode) specialKeyBackgroundColor else keyBackgroundColor)
            }
            spaceKey.background = spacebarDrawable
            spaceKey.textSize = 16f
            spaceKey.setTextColor(keyTextColor)
            
            // Variables for tracking swipe
            var startX = 0f
            val swipeThreshold = 20 // Minimum pixels to consider it a swipe
            var isSwiping = false
            
            spaceKey.setOnTouchListener { v, event ->
                // Check if we're in a text or search field
                val editorInfo = currentInputEditorInfo
                val inputType = editorInfo?.inputType ?: 0
                val isTextOrSearchField = when (inputType and InputType.TYPE_MASK_CLASS) {
                    InputType.TYPE_CLASS_TEXT -> true
                    InputType.TYPE_CLASS_NUMBER -> true
                    else -> false
                }
                
                when (event.action) {
                    MotionEvent.ACTION_DOWN -> {
                        startX = event.rawX
                        isSwiping = false
                        v.alpha = 0.7f // Visual feedback
                        true
                    }
                    MotionEvent.ACTION_MOVE -> {
                        // Only enable swipe in text/search fields
                        if (!isTextOrSearchField) return@setOnTouchListener false
                        
                        val deltaX = event.rawX - startX
                        if (Math.abs(deltaX.toFloat()) > swipeThreshold) {
                            isSwiping = true
                            // Move cursor left or right based on swipe direction
                            val keyCode = if (deltaX > 0) KeyEvent.KEYCODE_DPAD_RIGHT else KeyEvent.KEYCODE_DPAD_LEFT
                            val eventTime = SystemClock.uptimeMillis()
                            
                            // Send key events for cursor movement
                            currentInputConnection?.sendKeyEvent(KeyEvent(
                                eventTime, eventTime,
                                KeyEvent.ACTION_DOWN, keyCode, KeyEvent.META_CTRL_ON
                            ))
                            currentInputConnection?.sendKeyEvent(KeyEvent(
                                eventTime, eventTime,
                                KeyEvent.ACTION_UP, keyCode, 0
                            ))
                            
                            // Update startX for continuous movement
                            startX = event.rawX
                            
                            // Haptic feedback for better UX
                            if (isHapticFeedbackEnabled) {
                                v.performHapticFeedback(HapticFeedbackConstants.VIRTUAL_KEY)
                            }
                            return@setOnTouchListener true
                        }
                        false
                    }
                    MotionEvent.ACTION_UP -> {
                        v.alpha = 1.0f // Reset visual state
                        if (!isSwiping) {
                            // Only insert space if it wasn't a swipe
                            handleText(" ")
                        }
                        true
                    }
                    MotionEvent.ACTION_CANCEL -> {
                        v.alpha = 1.0f // Reset visual state
                        true
                    }
                    else -> false
                }
            }
        }
        // First Emoji Key Implementation (setupLettersKeyboard method)
// Replace lines 609-613 with this:
// Emoji key
addSpecialKey(bottomRow, "", R.drawable.ic_emoji, 1f) {
    if (isHapticFeedbackEnabled) performHapticFeedback()
    isEmojiKeyboardShown = !isEmojiKeyboardShown
    isSymbolsShown = false
    setupKeyboard()
    Log.d(TAG, "Emoji key pressed, emoji keyboard shown: $isEmojiKeyboardShown")
}
        
        // Create a custom button for return key - based on the working implementation from symbols layout
        val returnKey = Button(this).apply { // Changed from TextView to Button for better sizing
            text = "return"
            textSize = 10f // Reduced from 12f to prevent wrapping
            setAllCaps(false) // Prevent all-caps text transformation
            gravity = Gravity.CENTER
            setTextColor(Color.WHITE)
            maxLines = 1 // Ensure text stays on one line
            ellipsize = TextUtils.TruncateAt.END // Add ellipsis if text is too long
            
            // Use consistent padding to ensure proper height and text placement
            val paddingHorizDp = TypedValue.applyDimension(
                TypedValue.COMPLEX_UNIT_DIP, 
                4f, // Reduced from 8f to give more space for text
                resources.displayMetrics
            ).toInt()
            
            val paddingVerticalDp = TypedValue.applyDimension(
                TypedValue.COMPLEX_UNIT_DIP,
                2f, // Small vertical padding
                resources.displayMetrics
            ).toInt()
            
            setPadding(paddingHorizDp, paddingVerticalDp, paddingHorizDp, paddingVerticalDp)
            
            // Blue background
            val bgDrawable = GradientDrawable().apply {
                cornerRadius = TypedValue.applyDimension(
                    TypedValue.COMPLEX_UNIT_DIP,
                    6f,
                    resources.displayMetrics
                )
                setColor(Color.parseColor(themeColor)) // Use theme color
            }
            background = bgDrawable
            
            // Set layout parameters - increased weight for better fit
            layoutParams = LinearLayout.LayoutParams(0, ViewGroup.LayoutParams.MATCH_PARENT, 1.5f).apply {
                // Minimal margins to maximize size
                val marginDp = TypedValue.applyDimension(
                    TypedValue.COMPLEX_UNIT_DIP,
                    3f,
                    resources.displayMetrics
                ).toInt()
                setMargins(marginDp, marginDp, marginDp, marginDp)
            }
            
            // Set click listener - using the EXACT SAME logic that works in the symbols layout
            setOnClickListener {
                val ic = currentInputConnection ?: return@setOnClickListener // Get current input connection
                if (isHapticFeedbackEnabled) performHapticFeedback() // Perform haptic feedback if enabled

                Log.d(TAG, "QWERTY Return: multiLine=$currentInputTypeSupportsMultiLine, action=$currentEditorAction")
                
                // Check if the current input field supports multiple lines
                if (currentInputTypeSupportsMultiLine) { 
                    // If yes (e.g., messaging, notes), insert a newline character
                    ic.commitText("\n", 1) 
                } else { 
                    // If no (e.g., browser search bar, single-line input)
                    // Check if a specific editor action is defined (like Search, Go, Send)
                    if (currentEditorAction != EditorInfo.IME_ACTION_NONE) { 
                        // If yes, perform that specific action
                        ic.performEditorAction(currentEditorAction) 
                    } else { 
                        // If no specific action is defined, send a standard Enter key press
                        val eventTime = SystemClock.uptimeMillis()
                        ic.sendKeyEvent(KeyEvent(eventTime, eventTime, KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_ENTER, 0))
                        ic.sendKeyEvent(KeyEvent(eventTime, eventTime, KeyEvent.ACTION_UP, KeyEvent.KEYCODE_ENTER, 0))
                    }
                }
            }
        }
        
        // Add the return key to the bottom row
        bottomRow.addView(returnKey) // End of if (returnKey is Button)
    } // End of setupLettersKeyboard() method
    
    private fun setupSymbolsKeyboard() {
        // Update keyboard state
        keyboardState = KeyboardState.SYMBOLS
        
        // Show letter keyboard components for layout structure
        numberRow.visibility = View.VISIBLE
        rowQwerty.visibility = View.VISIBLE
        rowAsdf.visibility = View.VISIBLE
        rowZxcv.visibility = View.VISIBLE
        bottomRow.visibility = View.VISIBLE
        
        // Hide emoji keyboard if it's visible
        if (::emojiKeyboardContainer.isInitialized) {
            emojiKeyboardContainer.visibility = View.GONE
        }
        // Add number row
        for (char in "1234567890") {
            addKey(numberRow, char.toString()) { handleText(char.toString()) }
        }
        
        // Add symbols rows
        for (char in "-/:;()$&@\"") {
            addKey(rowQwerty, char.toString()) { handleText(char.toString()) }
        }
        
        // Add middle row with useful symbols (no empty keys)
        // Use gravity to ensure proper spacing
        rowAsdf.gravity = Gravity.CENTER_HORIZONTAL

        // Add commonly used symbols that were missing from the layout
        // Added symbols: period, comma, question mark, exclamation, apostrophe, asterisk, percentage, underscore, caret, tilde
        for (char in ".,?!'*%_^~") {
            addKey(rowAsdf, char.toString(), 0, 1f) { handleText(char.toString()) }
        }
        
        // Add bottom symbols row
        addSpecialKey(rowZxcv, "#+=", null, 1.5f, true) {
            // Would show more symbols
            Log.d(TAG, "More symbols key pressed")
        }
        
        for (char in "[]{}<>") {
            addKey(rowZxcv, char.toString()) { handleText(char.toString()) }
        }
        
        // Replace return key next to '>' with backspace key with turbo delete
        val backspaceKey = addSpecialKey(rowZxcv, "", R.drawable.ic_backspace, 1.5f) { 
            // The onClick is overridden by the setOnTouchListener below
        }
        
        // Add turbo delete with word deletion on long press
        backspaceKey.setOnTouchListener { v, event ->
            val ic = currentInputConnection ?: return@setOnTouchListener false
            when (event.action) {
                MotionEvent.ACTION_DOWN -> {
                    v.alpha = 0.7f // Visual feedback for press
                    isDeleting = true
                    deleteCount = 0
                    handleBackspace(ic) // Initial delete
                    
                    // Start checking for long press after 3 seconds
                    deleteHandler.postDelayed({
                        if (isDeleting) {
                            // Delete entire word
                            val wordToDelete = ic.getTextBeforeCursor(100, 0)?.toString()
                            if (!wordToDelete.isNullOrEmpty()) {
                                val lastSpace = wordToDelete.lastIndexOf(' ')
                                val charsToDelete = if (lastSpace == -1) {
                                    wordToDelete.length
                                } else {
                                    wordToDelete.length - lastSpace - 1
                                }
                                
                                if (charsToDelete > 0) {
                                    ic.deleteSurroundingText(charsToDelete, 0)
                                    if (isHapticFeedbackEnabled) {
                                        v.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS)
                                    }
                                }
                            }
                        }
                    }, 3000) // 3 second delay for word delete

                    deleteRunnable = Runnable {
                        if (isDeleting) {
                            handleBackspace(ic)
                            deleteCount++
                            val delay = if (deleteCount >= maxDeletesBeforeTurbo) turboDeleteDelay else repeatDeleteDelay
                            deleteHandler.postDelayed(deleteRunnable, delay)
                        }
                    }
                    deleteHandler.postDelayed(deleteRunnable, initialDeleteDelay)
                    true
                }
                MotionEvent.ACTION_UP, MotionEvent.ACTION_CANCEL -> {
                    isDeleting = false
                    deleteHandler.removeCallbacks(deleteRunnable)
                    // Also remove the long press callback
                    deleteHandler.removeCallbacksAndMessages(null)
                    v.alpha = 1.0f // Reset visual feedback
                    true
                }
                else -> false
            }
        }
        
        // Add bottom row
        // ABC key
        addSpecialKey(bottomRow, "ABC", null, 1.5f, true) {
            if (isHapticFeedbackEnabled) performHapticFeedback()
            isSymbolsShown = false
            setupKeyboard()
        }
        
        // Globe key (language)
        addSpecialKey(bottomRow, "", R.drawable.ic_globe, 1f) {
            // Would show language options
            Log.d(TAG, "Globe key pressed")
        }
        
        // Space bar with slightly reduced width
        // Space bar with swipe navigation for Symbols Keyboard
    var localSymbolsSpaceStartX = 0f // Captured by the listener lambda
    var localSymbolsSpaceIsSwiping = false // Captured by the listener lambda
    val spaceKeySymbols = addKey(bottomRow, "space", 0, 4f, false, true) { 
        // Tap action is now primarily handled by the OnTouchListener's ACTION_UP.
        // This onClick can be an empty lambda or a fallback.
        // handleText(" ", true) // Redundant if OnTouchListener handles tap reliably.
    }
    spaceKeySymbols.setOnTouchListener { v, event ->
        val ic = currentInputConnection ?: return@setOnTouchListener false

        when (event.action) {
            MotionEvent.ACTION_DOWN -> {
                localSymbolsSpaceStartX = event.rawX
                localSymbolsSpaceIsSwiping = false
                // Haptic on press for tap is handled by handleText in ACTION_UP.
                // For swipe initiation, this provides immediate feedback.
                if (isHapticFeedbackEnabled) v.performHapticFeedback(HapticFeedbackConstants.VIRTUAL_KEY)
                v.alpha = 0.7f
                true
            }
            MotionEvent.ACTION_MOVE -> {
                if (!isTextOrSearchField) return@setOnTouchListener false // Only allow swipe in text fields
                val deltaX = event.rawX - localSymbolsSpaceStartX
                if (Math.abs(deltaX.toFloat()) > SWIPE_THRESHOLD) { // SWIPE_THRESHOLD is a class member
                    localSymbolsSpaceIsSwiping = true
                    val keyCode = if (deltaX > 0) KeyEvent.KEYCODE_DPAD_RIGHT else KeyEvent.KEYCODE_DPAD_LEFT
                    val eventTime = SystemClock.uptimeMillis()
                    ic.sendKeyEvent(KeyEvent(eventTime, eventTime, KeyEvent.ACTION_DOWN, keyCode, KeyEvent.META_CTRL_ON))
                    ic.sendKeyEvent(KeyEvent(eventTime, eventTime, KeyEvent.ACTION_UP, keyCode, 0))
                    localSymbolsSpaceStartX = event.rawX // Update for continuous movement
                    if (isHapticFeedbackEnabled) {
                        v.performHapticFeedback(HapticFeedbackConstants.VIRTUAL_KEY) // Haptic for each swipe segment
                    }
                    return@setOnTouchListener true // Consume the event as it's a swipe action
                }
                false // Not a swipe significant enough to act upon yet
            }
            MotionEvent.ACTION_UP -> {
                v.alpha = 1.0f // Reset visual feedback
                if (!localSymbolsSpaceIsSwiping) {
                    // If not a swipe, treat as a tap.
                    handleText(" ", true) // Perform space insertion and haptic feedback.
                }
                // Reset swipe state for the next touch operation
                localSymbolsSpaceIsSwiping = false 
                true // Consume the event
            }
            MotionEvent.ACTION_CANCEL -> {
                v.alpha = 1.0f // Reset visual feedback
                localSymbolsSpaceIsSwiping = false
                true // Consume the event
            }
            else -> false // Don't consume other actions
        }
    }
        
        // Second Emoji Key Implementation (setupSymbolsKeyboard method)
// Replace lines 798-801 with this:
// Emoji key
addSpecialKey(bottomRow, "", R.drawable.ic_emoji, 1f) {
    if (isHapticFeedbackEnabled) performHapticFeedback()
    isEmojiKeyboardShown = !isEmojiKeyboardShown
    isSymbolsShown = false
    setupKeyboard()
    Log.d(TAG, "Emoji key pressed, emoji keyboard shown: $isEmojiKeyboardShown")
}
        
        // Custom styled blue return key with exact height match to emoji key
        val returnKey = Button(this).apply { // Changed from TextView to Button for better sizing
            text = "return"
            textSize = 10f // Reduced from 12f to prevent wrapping
            setAllCaps(false) // Prevent all-caps text transformation
            gravity = Gravity.CENTER
            setTextColor(Color.WHITE)
            maxLines = 1 // Ensure text stays on one line
            ellipsize = TextUtils.TruncateAt.END // Add ellipsis if text is too long
            
            // Use consistent padding to ensure proper height and text placement
            val paddingHorizDp = TypedValue.applyDimension(
                TypedValue.COMPLEX_UNIT_DIP, 
                4f, // Reduced from 8f to give more space for text
                resources.displayMetrics
            ).toInt()
            
            val paddingVerticalDp = TypedValue.applyDimension(
                TypedValue.COMPLEX_UNIT_DIP,
                2f, // Small vertical padding
                resources.displayMetrics
            ).toInt()
            
            setPadding(paddingHorizDp, paddingVerticalDp, paddingHorizDp, paddingVerticalDp)
            
            // Blue background
            val bgDrawable = GradientDrawable().apply {
                cornerRadius = TypedValue.applyDimension(
                    TypedValue.COMPLEX_UNIT_DIP,
                    6f,
                    resources.displayMetrics
                )
                setColor(Color.parseColor("#007AFF")) // iOS blue color
            }
            background = bgDrawable
            
            // Set layout parameters - increased weight for better fit
            layoutParams = LinearLayout.LayoutParams(0, ViewGroup.LayoutParams.MATCH_PARENT, 2f).apply {
                // Minimal margins to maximize size
                val marginDp = TypedValue.applyDimension(
                    TypedValue.COMPLEX_UNIT_DIP,
                    3f,
                    resources.displayMetrics
                ).toInt()
                setMargins(marginDp, marginDp, marginDp, marginDp)
            }
            
                        // Set click listener
                        setOnClickListener {
                            val ic = currentInputConnection ?: return@setOnClickListener // Get current input connection
                            if (isHapticFeedbackEnabled) performHapticFeedback() // Perform haptic feedback if enabled
            
                            // Check if the current input field supports multiple lines
                            if (currentInputTypeSupportsMultiLine) { 
                                // If yes (e.g., messaging, notes), insert a newline character
                                ic.commitText("\n", 1) 
                            } else { 
                                // If no (e.g., browser search bar, single-line input)
                                // Check if a specific editor action is defined (like Search, Go, Send)
                                if (currentEditorAction != EditorInfo.IME_ACTION_NONE) { 
                                    // If yes, perform that specific action
                                    ic.performEditorAction(currentEditorAction) 
                                } else { 
                                    // If no specific action is defined, send a standard Enter key press
                                    val eventTime = SystemClock.uptimeMillis()
                                    ic.sendKeyEvent(KeyEvent(eventTime, eventTime, KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_ENTER, 0))
                                    ic.sendKeyEvent(KeyEvent(eventTime, eventTime, KeyEvent.ACTION_UP, KeyEvent.KEYCODE_ENTER, 0))
                                }
                            }
                        }
        }
        bottomRow.addView(returnKey)
    }
    
    /**
     * Sets up the emoji keyboard layout
     */

    // Populates the emoji grid with emojis from the current category
    private fun populateEmojiGrid() {
        emojiGridContainer.removeAllViews() // Clear previous emojis

        if (currentEmojiCategoryIndex < 0 || currentEmojiCategoryIndex >= emojiCategories.size) {
            Log.e(TAG, "Invalid emoji category index: $currentEmojiCategoryIndex")
            return
        }

        val (_, emojis) = emojiCategories[currentEmojiCategoryIndex]
        var emojiCounter = 0
        // val totalEmojisInPage = EMOJI_ROWS * EMOJI_COLUMNS // Not strictly needed for this simple version

        for (i in 0 until EMOJI_ROWS) {
            val rowLayout = LinearLayout(this).apply {
                orientation = LinearLayout.HORIZONTAL
                layoutParams = LinearLayout.LayoutParams(
                    LinearLayout.LayoutParams.MATCH_PARENT,
                    LinearLayout.LayoutParams.WRAP_CONTENT // Height will be determined by keys
                )
            }
            for (j in 0 until EMOJI_COLUMNS) {
                if (emojiCounter < emojis.size) {
                    val emoji = emojis[emojiCounter]
                    addKey(rowLayout, emoji, weight = 1f) { handleText(emoji) }
                    emojiCounter++
                } else {
                    // Add an empty placeholder view to maintain grid structure
                    val emptyView = View(this)
                    // Ensure empty view takes up space and has a defined height (e.g., key height)
                    val params = LinearLayout.LayoutParams(0, dpToPx(55), 1f) 
                    emptyView.layoutParams = params
                    rowLayout.addView(emptyView)
                }
            }
            emojiGridContainer.addView(rowLayout)
        }
        updateEmojiCategoryIndicator() // Update dots after populating grid
    }

    // Updates the category indicator dots
    private fun updateEmojiCategoryIndicator() {
        emojiCategoryIndicatorContainer.removeAllViews()
        for (i in emojiCategories.indices) {
            val dot = View(this).apply {
                layoutParams = LinearLayout.LayoutParams(dpToPx(8), dpToPx(8)).apply {
                    setMargins(dpToPx(4), dpToPx(4), dpToPx(4), dpToPx(4)) // Added some vertical margin for dots
                }
                val shape = GradientDrawable().apply {
                    shape = GradientDrawable.OVAL
                    setColor(if (i == currentEmojiCategoryIndex) Color.parseColor(themeColor) else Color.LTGRAY)
                    setSize(dpToPx(8), dpToPx(8))
                }
                background = shape
            }
            emojiCategoryIndicatorContainer.addView(dot)
        }
    }

    // Creates the category selection tabs (or buttons)
    private fun createEmojiCategoryTabs() {
        emojiCategoryTabsContainer.removeAllViews()
        // Using representative emojis for category tabs. Could be replaced with icons.
        val categoryTabRepresentations = listOf("ğŸ˜€", "ğŸ¨", "ğŸš—", "â­", "âœ‚ï¸", "ğŸ§©", "ğŸª") 

        for (i in emojiCategories.indices) {
            val (categoryName, _) = emojiCategories[i]
            // Use predefined representation or fallback to first char of category name
            val tabRepresentation = categoryTabRepresentations.getOrElse(i) { categoryName.firstOrNull()?.toString() ?: "?" }

            val tabButton = Button(this).apply {
                text = tabRepresentation
                layoutParams = LinearLayout.LayoutParams(0, LinearLayout.LayoutParams.MATCH_PARENT, 1f)
                // Style similar to other special keys
                setTextSize(TypedValue.COMPLEX_UNIT_SP, 22f) // Emoji font size for tab
                setBackgroundColor(Color.TRANSPARENT) // Or use specialKeyBackgroundColor if defined and suitable
                setTextColor(keyTextColor) // Use keyboard's text color
                setPadding(dpToPx(2), dpToPx(2), dpToPx(2), dpToPx(2)) // Minimal padding

                setOnClickListener {
                    if (isHapticFeedbackEnabled) performHapticFeedback()
                    if (currentEmojiCategoryIndex != i) {
                        currentEmojiCategoryIndex = i
                        populateEmojiGrid() // This will also call updateEmojiCategoryIndicator
                    }
                }
            }
            emojiCategoryTabsContainer.addView(tabButton)
        }
    }

    // Variables for swipe detection on the emoji grid
    private var emojiGridSwipeInitialX = 0f
    // Using the existing SWIPE_THRESHOLD constant for consistency

    // Sets up swipe detection for the emoji grid container
    @SuppressLint("ClickableViewAccessibility")
    private fun setupEmojiSwipeDetection() {
        emojiGridContainer.setOnTouchListener { _, event -> // v is unused, replaced with _
            when (event.action) {
                MotionEvent.ACTION_DOWN -> {
                    emojiGridSwipeInitialX = event.x
                    true // Consume the event to handle swipe
                }
                MotionEvent.ACTION_MOVE -> {
                    // Must return true if ACTION_DOWN returned true and you want to receive ACTION_MOVE/UP.
                    true
                }
                MotionEvent.ACTION_UP -> {
                    val deltaX = event.x - emojiGridSwipeInitialX
                    var swiped = false
                    if (Math.abs(deltaX) > SWIPE_THRESHOLD) { // Use existing SWIPE_THRESHOLD
                        if (deltaX < 0) { // Swiped Left (next category)
                            currentEmojiCategoryIndex = (currentEmojiCategoryIndex + 1) % emojiCategories.size
                        } else { // Swiped Right (previous category)
                            currentEmojiCategoryIndex = (currentEmojiCategoryIndex - 1 + emojiCategories.size) % emojiCategories.size
                        }
                        if (isHapticFeedbackEnabled) performHapticFeedback()
                        populateEmojiGrid() // This also updates indicators
                        swiped = true
                    }
                    // If swiped, event is consumed. Otherwise, child views (emoji keys) handle their own taps.
                    swiped 
                }
                else -> false // For other actions, don't consume
            }
        }
    }

private fun setupEmojiKeyboard() {
    Log.d(TAG, "setupEmojiKeyboard called. Initial state: isEmojiKeyboardShown=$isEmojiKeyboardShown, isSymbolsShown=$isSymbolsShown")
    
    // Update keyboard state
    keyboardState = KeyboardState.EMOJI
    keyboardContainer.removeAllViews() // Clear the main container for a fresh emoji keyboard setup

    // Initialize the main emoji keyboard container (FrameLayout for potential layering, e.g., pop-ups)
    emojiKeyboardContainer = FrameLayout(this).apply {
        layoutParams = FrameLayout.LayoutParams(
            FrameLayout.LayoutParams.MATCH_PARENT,
            FrameLayout.LayoutParams.MATCH_PARENT
        )
        // Consider setting background color if keyboardContainer doesn't provide one
        // or if a distinct emoji panel background is desired.
        // setBackgroundColor(keyboardBackgroundColor) 
    }

    // Vertical LinearLayout to hold the grid, indicators, tabs, and bottom controls
    val emojiMainLayout = LinearLayout(this).apply {
        orientation = LinearLayout.VERTICAL
        layoutParams = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.MATCH_PARENT,
            LinearLayout.LayoutParams.MATCH_PARENT
        )
    }

    // 1. Emoji Grid Container (where emojis are displayed)
    emojiGridContainer = LinearLayout(this).apply {
        orientation = LinearLayout.VERTICAL
        layoutParams = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.MATCH_PARENT,
            0, // Height is 0, weight 1f means it takes available vertical space
            1f  // Weight to make it expand and fill available space
        )
        // Optional: set padding or background for the grid area
        // setPadding(dpToPx(2), dpToPx(2), dpToPx(2), dpToPx(2))
    }
    emojiMainLayout.addView(emojiGridContainer)

    // 2. Emoji Category Indicator Container (dots)
    emojiCategoryIndicatorContainer = LinearLayout(this).apply {
        orientation = LinearLayout.HORIZONTAL
        layoutParams = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.MATCH_PARENT,
            LinearLayout.LayoutParams.WRAP_CONTENT // Height based on dot size + margins
        )
        gravity = Gravity.CENTER
        setPadding(0, dpToPx(2), 0, dpToPx(6)) // Padding around dots area
    }
    emojiMainLayout.addView(emojiCategoryIndicatorContainer)
    
    // 3. Emoji Category Tabs Container (buttons for direct category selection)
    emojiCategoryTabsContainer = LinearLayout(this).apply {
        orientation = LinearLayout.HORIZONTAL
        layoutParams = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.MATCH_PARENT,
            dpToPx(45) // Fixed height for category tabs row
        )
        gravity = Gravity.CENTER_VERTICAL // Center tabs vertically
        // Optional: set background for tab row
        // setBackgroundColor(specialKeyBackgroundColor) 
    }
    emojiMainLayout.addView(emojiCategoryTabsContainer)

    // 4. Bottom Control Row (ABC, Space, Backspace)
    val emojiBottomControlRow = LinearLayout(this).apply {
        orientation = LinearLayout.HORIZONTAL
        layoutParams = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.MATCH_PARENT,
            dpToPx(55) // Standard key height for this row
        )
        gravity = Gravity.CENTER_VERTICAL
        // Optional: set background for control row
        // setBackgroundColor(keyboardBackgroundColor)
    }

    // Add ABC key to switch back to letter keyboard
    addSpecialKey(emojiBottomControlRow, "ABC", null, 1.5f, true) {
        Log.d(TAG, "Emoji Panel: ABC key pressed. Directly switching to letters keyboard")
        if (isHapticFeedbackEnabled) performHapticFeedback()
        
        // Reset state variables
        isEmojiKeyboardShown = false
        isSymbolsShown = false
        
        // Clear the keyboard container
        keyboardContainer.removeAllViews()
        
        // Recreate the main keyboard layout
        val keyboardLayout = LinearLayout(this)
        keyboardLayout.orientation = LinearLayout.VERTICAL
        keyboardLayout.layoutParams = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.MATCH_PARENT,
            LinearLayout.LayoutParams.WRAP_CONTENT
        )
        
        // Add keyboard layout to container
        keyboardContainer.addView(keyboardLayout)
        
        // Create keyboard rows
        numberRow = LinearLayout(this)
        numberRow.layoutParams = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.MATCH_PARENT,
            LinearLayout.LayoutParams.WRAP_CONTENT
        )
        
        rowQwerty = LinearLayout(this)
        rowQwerty.layoutParams = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.MATCH_PARENT,
            LinearLayout.LayoutParams.WRAP_CONTENT
        )
        
        rowAsdf = LinearLayout(this)
        rowAsdf.layoutParams = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.MATCH_PARENT,
            LinearLayout.LayoutParams.WRAP_CONTENT
        )
        
        rowZxcv = LinearLayout(this)
        rowZxcv.layoutParams = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.MATCH_PARENT,
            LinearLayout.LayoutParams.WRAP_CONTENT
        )
        
        bottomRow = LinearLayout(this)
        bottomRow.layoutParams = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.MATCH_PARENT,
            LinearLayout.LayoutParams.WRAP_CONTENT
        )
        
        // Add rows to keyboard layout
        keyboardLayout.addView(numberRow)
        keyboardLayout.addView(rowQwerty)
        keyboardLayout.addView(rowAsdf)
        keyboardLayout.addView(rowZxcv)
        keyboardLayout.addView(bottomRow)
        
        // Setup the letters keyboard
        setupLettersKeyboard()
        
        Log.d(TAG, "Emoji Panel: ABC key - Successfully switched to letters keyboard")
    }

    // Add Space bar for emoji panel
    // Double-space for period is handled by handleText
    addKey(emojiBottomControlRow, "space", weight = 5f, isSpacebar = true) {
        handleText(" ", true) // enableHaptic = true for tap, double-space logic in handleText
    }

    // Add Backspace key for emoji panel with turbo delete
    val emojiBackspaceKey = addSpecialKey(emojiBottomControlRow, "", R.drawable.ic_backspace, 1.5f) {
        // Fallback onClick, primarily handled by OnTouchListener
    }
    emojiBackspaceKey.setOnTouchListener { v, event ->
        val ic = currentInputConnection ?: return@setOnTouchListener false
        when (event.action) {
            MotionEvent.ACTION_DOWN -> {
                v.alpha = 0.7f // Visual feedback
                // Start word delete timer
                wordDeleteRunnable = Runnable {
                    isWordDeleteActive = true
                    if (isHapticFeedbackEnabled) v.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS)
                    handleBackspace(ic, true) // isWordDelete's haptic is in handleBackspace
                }
                deleteHandler.postDelayed(wordDeleteRunnable!!, wordDeleteDelay)
                
                // Initial delete (haptic feedback is in handleBackspace)
                handleBackspace(ic, false)
                
                // Start turbo delete sequence
                isDeleting = true
                deleteCount = 0
                deleteRunnable = object : Runnable {
                    override fun run() {
                        if (isDeleting) {
                            handleBackspace(ic, isWordDeleteActive) // Haptic is in handleBackspace
                            deleteCount++
                            val delay = if (deleteCount >= maxDeletesBeforeTurbo) turboDeleteDelay else repeatDeleteDelay
                            deleteHandler.postDelayed(this, delay)
                        }
                    }
                }
                deleteHandler.postDelayed(deleteRunnable, initialDeleteDelay)
                true
            }
            MotionEvent.ACTION_UP, MotionEvent.ACTION_CANCEL -> {
                isDeleting = false
                isWordDeleteActive = false
                wordDeleteRunnable?.let { deleteHandler.removeCallbacks(it) }
                deleteHandler.removeCallbacks(deleteRunnable)
                v.alpha = 1.0f // Reset visual feedback
                true
            }
            else -> false
        }
    }
    emojiMainLayout.addView(emojiBottomControlRow)

    // Add the structured emojiMainLayout to the emojiKeyboardContainer
    emojiKeyboardContainer.addView(emojiMainLayout)
    
    // Add the emojiKeyboardContainer to the main keyboardContainer (from InputMethodService)
    keyboardContainer.addView(emojiKeyboardContainer)

    // Initial population and setup for the emoji categories
    currentEmojiCategoryIndex = 0 // Default to the first category
    populateEmojiGrid()       // Fill the grid with emojis from the current category
    createEmojiCategoryTabs() // Create the category selection tabs
    setupEmojiSwipeDetection()// Enable swipe gestures on the emoji grid for category navigation
    
    Log.d(TAG, "New emoji keyboard with categories setup complete.")
    Log.d(TAG, "setupEmojiKeyboard finished. Final state: isEmojiKeyboardShown=$isEmojiKeyboardShown, isSymbolsShown=$isSymbolsShown")
}
    
    private fun addKey(
        parent: ViewGroup,
        text: String,
        width: Int = 0,
        weight: Float = 1f,
        isSpecial: Boolean = false,
        isSpacebar: Boolean = false,
        onClick: () -> Unit
    ): Button {
        val keyView = LayoutInflater.from(this).inflate(
            R.layout.ios_key_letter, 
            parent,
            false
        ) as Button

        keyView.text = if (text == "space") " " else text

        keyView.setBackgroundColor(keyBackgroundColor)
        keyView.setTextColor(keyTextColor)

        val backgroundDrawable = ContextCompat.getDrawable(this, R.drawable.ios_key_background)?.mutate()
        if (backgroundDrawable != null) {
            DrawableCompat.setTint(backgroundDrawable, keyBackgroundColor)
            keyView.background = backgroundDrawable
        }

        val params = if (width == 0) {
            LinearLayout.LayoutParams(
                0, 
                resources.getDimensionPixelSize(R.dimen.ios_key_height),
                weight
            )
        } else {
            LinearLayout.LayoutParams(
                width, 
                resources.getDimensionPixelSize(R.dimen.ios_key_height),
                weight 
            )
        }.apply {
            val margin = resources.getDimensionPixelSize(R.dimen.ios_key_margin) / 2
            setMargins(margin, margin, margin, margin)
        }
        keyView.layoutParams = params

        keyView.setOnTouchListener { v, event ->
            when (event.action) {
                MotionEvent.ACTION_DOWN -> {
                    v.alpha = 0.7f
                    // Show popup immediately for all non-whitespace keys
                    if (text.isNotBlank() && text != "\n") {
                        showKeyPopup(v, text)
                    }
                    // Post the click to ensure popup shows first
                    v.post { onClick() }
                    true
                }
                MotionEvent.ACTION_UP, MotionEvent.ACTION_CANCEL -> {
                    v.alpha = 1.0f
                    // Dismiss popup when finger is lifted
                    dismissKeyPopup()
                    true
                }
                MotionEvent.ACTION_MOVE -> {
                    // Always update popup position while moving
                    if (text.isNotBlank() && text != "\n") {
                        if (currentPopupKey == v) {
                            updatePopupPosition(v)
                        } else {
                            // If we moved to a different key, dismiss the popup
                            dismissKeyPopup()
                        }
                    }
                    true
                }
                else -> false
            }
        }

        parent.addView(keyView)
        return keyView
    }
    
    private fun showKeyPopup(anchor: View, text: String) {
        try {
            // Skip if already showing popup for this key
            if (currentPopupKey == anchor) {
                updatePopupPosition(anchor)
                return
            }
            
            // Dismiss any existing popup
            dismissKeyPopup()

            val inflater = getSystemService(Context.LAYOUT_INFLATER_SERVICE) as LayoutInflater
            val popupView = inflater.inflate(R.layout.key_popup, null)
            val popupText = popupView.findViewById<TextView>(R.id.popup_text)
            // Show the letter in the correct case based on keyboard state
            popupText.text = if (isCapsOn || isCapsLock) text.uppercase() else text.lowercase()
            
            // Get the key's background color
            val background = anchor.background
            var bgColor = Color.LTGRAY // Default color
            
            if (background is android.graphics.drawable.ColorDrawable) {
                bgColor = background.color
            } else if (background is android.graphics.drawable.GradientDrawable) {
                val constantState = background.constantState
                constantState?.let {
                    val drawable = it.newDrawable().mutate() as android.graphics.drawable.GradientDrawable
                    drawable.setColorFilter(bgColor, android.graphics.PorterDuff.Mode.SRC_ATOP)
                }
            }
            
            // Set the popup background (the circle is handled by the background drawable)
            // Set the popup background based on theme
            val popupBackgroundResId = if (isDarkMode) R.drawable.key_popup_background_dark else R.drawable.key_popup_background
            popupView.background = ContextCompat.getDrawable(this@RewordiumAIKeyboardService, popupBackgroundResId)
            
            // Set text color based on theme
            val textColor = if (isDarkMode) Color.WHITE else Color.BLACK
            popupText.setTextColor(textColor)
            
            // Create the popup window
            // Create a perfectly circular popup
            val popupSize = dpToPx(54)
            keyPopup = PopupWindow(
                popupView,
                popupSize,
                popupSize,
                false
            ).apply {
                // Set background to transparent to show the shadow
                setBackgroundDrawable(android.graphics.drawable.ColorDrawable(Color.TRANSPARENT))
                
                // Disable all animations for instant appearance
                animationStyle = 0
                
                // Set elevation for shadow (iOS uses a more subtle shadow)
                elevation = 4f
                
                // Don't dismiss when touched outside
                isOutsideTouchable = false
                isFocusable = false
                isTouchable = false
                
                // Set input method mode to not need adjustment (reduces delay)
                inputMethodMode = PopupWindow.INPUT_METHOD_NOT_NEEDED
            }
            
            // Show the popup
            updatePopupPosition(anchor)
            currentPopupKey = anchor
        } catch (e: Exception) {
            Log.e("KeyPopup", "Error showing key popup", e)
        }
    }
    
    private fun updatePopupPosition(anchor: View) {
        keyPopup?.let { popup ->
            try {
                // Get the anchor view's location on screen
                val anchorLocation = IntArray(2)
                anchor.getLocationInWindow(anchorLocation)
                
                // Calculate popup position (centered above the key with offset for the triangle)
                val x = anchorLocation[0] + (anchor.width - popup.width) / 2
                // Position the popup above the key with a small gap
                val y = anchorLocation[1] - popup.height - dpToPx(4)
                
                // Get screen dimensions
                val displayMetrics = resources.displayMetrics
                val screenWidth = displayMetrics.widthPixels
                
                // Adjust x position to keep popup on screen with some padding
                val padding = dpToPx(8)
                var adjustedX = x
                
                if (adjustedX < padding) {
                    adjustedX = padding
                } else if (adjustedX + popup.width > screenWidth - padding) {
                    adjustedX = screenWidth - popup.width - padding
                }
                
                // Calculate y position with padding from top
                val adjustedY = y.coerceAtLeast(padding)
                
                // Update popup position
                if (!popup.isShowing) {
                    popup.showAtLocation(
                        anchor,
                        Gravity.TOP or Gravity.START,
                        adjustedX,
                        adjustedY
                    )
                } else {
                    popup.update(adjustedX, adjustedY, -1, -1)
                }
            } catch (e: Exception) {
                Log.e("KeyPopup", "Error updating popup position", e)
            }
        }
    }
    
    private fun dismissKeyPopup() {
        try {
            keyPopup?.let { popup ->
                if (popup.isShowing) {
                    popup.dismiss()
                }
            }
        } catch (e: Exception) {
            Log.e("KeyPopup", "Error dismissing popup", e)
        } finally {
            keyPopup = null
            currentPopupKey = null
        }
    }
    
    private fun dpToPx(dp: Int): Int {
        return (dp * resources.displayMetrics.density).toInt()
    }

    private fun addSpecialKey(
        parent: ViewGroup,
        text: String,
        iconResId: Int? = null,
        weight: Float = 1f,
        isTextKey: Boolean = false,
        onClick: () -> Unit
    ): View {
        val view = if (isTextKey) {
            // Text-based special key
            val keyView = LayoutInflater.from(this).inflate(
                R.layout.ios_key_special,
                parent,
                false
            ) as Button
            
            keyView.text = text
            // Adjust text color for dark mode for keys like '123', 'ABC', '#+=', 'space'
            if (mIsDarkMode) {
                keyView.setTextColor(Color.WHITE)
            } else {
                keyView.setTextColor(keyTextColor) // Use the standard key text color in light mode
            }
            keyView
        } else {
            // Icon-based special key
            val keyView = LayoutInflater.from(this).inflate(
                R.layout.ios_key_icon,
                parent,
                false
            ) as ImageButton
            
            if (iconResId != null) {
                keyView.setImageResource(iconResId)
                
                // Apply theme color to icon
                val drawable = keyView.drawable.mutate()
                drawable.colorFilter = PorterDuffColorFilter(
                    Color.parseColor(themeColor),
                    PorterDuff.Mode.SRC_IN
                )
            }
            keyView
        }
        
        // Apply special key background with rounded corners
        val backgroundDrawable = GradientDrawable().apply {
            cornerRadius = TypedValue.applyDimension(
                TypedValue.COMPLEX_UNIT_DIP,
                6f,
                resources.displayMetrics
            )
            // Use the special key background color
            setColor(specialKeyBackgroundColor)
        }
        view.background = backgroundDrawable
        
        // For icon-based keys (like backspace), ensure proper padding
        if (view is ImageButton) {
            view.setPadding(0, 10, 0, 0)
        }
        
        val params = LinearLayout.LayoutParams(
            0, 
            resources.getDimensionPixelSize(R.dimen.ios_key_height),
            weight
        ).apply {
            val margin = resources.getDimensionPixelSize(R.dimen.ios_key_margin) / 2
            setMargins(margin, margin, margin, margin)
        }
        
        view.layoutParams = params
        // Special handling for return key - to ensure it works with context-specific actions
        if (text.equals("return", ignoreCase = true)) {
            // Track if we've already triggered the action to prevent double execution
            var actionTriggered = false
            
            // For return key, directly set the OnClickListener with context-aware logic
            view.setOnClickListener {
                // This should run when user lifts finger
                if (!actionTriggered) {
                    actionTriggered = true
                    onClick()
                    // Reset after a delay
                    Handler(Looper.getMainLooper()).postDelayed({ actionTriggered = false }, 100)
                }
            }
            
            // For visual feedback only, no haptic feedback here
            view.setOnTouchListener { v, event ->
                when (event.action) {
                    MotionEvent.ACTION_DOWN -> {
                        // Visual feedback only
                        v.alpha = 0.7f
                        false // Don't consume the event
                    }
                    MotionEvent.ACTION_UP -> {
                        // Reset visual state and perform click (which triggers our onClick)
                        v.alpha = 1.0f
                        v.performClick() // Explicitly trigger the click
                        true // Consume this event after triggering the click
                    }
                    MotionEvent.ACTION_CANCEL -> {
                        // Just reset visual state
                        v.alpha = 1.0f
                        false
                    }
                    else -> false
                }
            }
        } else {
            // For all other special keys, use the original behavior: immediate response on ACTION_DOWN
            view.setOnTouchListener { v, event ->
                when (event.action) {
                    MotionEvent.ACTION_DOWN -> {
                        // Visual feedback
                        v.alpha = 0.7f
                        // Perform click action immediately on touch down
                        onClick()
                        true // Consume the event
                    }
                    MotionEvent.ACTION_UP, MotionEvent.ACTION_CANCEL -> {
                        // Reset visual state
                        v.alpha = 1.0f
                        true // Consume the event
                    }
                    else -> false
                }
            }
            
            // Keep click listener as fallback for accessibility
            view.setOnClickListener {
                // Action already handled in touch listener
            }
        }
        
        parent.addView(view)
        return view
    }
    
    private fun toggleCapsLock() {
        if (isHapticFeedbackEnabled) performHapticFeedback()

        val currentTime = System.currentTimeMillis()
        
        if (isCapsLock) {
            // If already in caps lock, a single tap will turn it off
            isCapsLock = false
            isCapsOn = false
        } else {
            // Check if this is a fast double-tap on shift (within 200ms)
            if (isCapsOn && currentTime - lastShiftTime < 200) {
                // Fast double-tap detected, activate caps lock
                isCapsLock = true
            } else if (isCapsOn) {
                // Second tap after normal shift (not a fast double-tap)
                // Toggle back to normal state
                isCapsOn = false
            } else {
                // First tap - turn on shift
                isCapsOn = true
            }
        }
        
        // Update the shift key last press time
        lastShiftTime = currentTime
        
        // Update the keyboard layout
        setupKeyboard()
    }
    
    private fun handleBackspace(ic: InputConnection, isWordDelete: Boolean = false) {
        // Provide haptic feedback for each deletion
        if (isHapticFeedbackEnabled) {
            performHapticFeedback()
        }

        val selectedText = ic.getSelectedText(0)
        if (selectedText.isNullOrEmpty()) {
            if (isWordDelete) {
                // Delete entire word
                val wordToDelete = ic.getTextBeforeCursor(100, 0)?.toString()
                if (!wordToDelete.isNullOrEmpty()) {
                    val lastSpace = wordToDelete.lastIndexOf(' ')
                    val charsToDelete = if (lastSpace == -1) {
                        wordToDelete.length
                    } else {
                        wordToDelete.length - lastSpace - 1
                    }
                    
                    if (charsToDelete > 0) {
                        ic.deleteSurroundingText(charsToDelete, 0)
                        if (isHapticFeedbackEnabled) {
                            performHapticFeedback()
                        }
                        return
                    }
                }
            }
            
            // Regular character deletion
            // Use KEYCODE_DEL for potentially better handling of complex characters like emojis
        val textBeforeCursor = ic.getTextBeforeCursor(1, 0) // Check if there's anything to delete
        if (!textBeforeCursor.isNullOrEmpty()) {
            val eventTime = SystemClock.uptimeMillis()
            ic.sendKeyEvent(KeyEvent(eventTime, eventTime, KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_DEL, 0))
            ic.sendKeyEvent(KeyEvent(eventTime, eventTime + 10, KeyEvent.ACTION_UP, KeyEvent.KEYCODE_DEL, 0)) // Small delay for UP event
        }
        } else {
            // Delete the selection
            ic.commitText("", 1)
        }
        
        // Turn off caps if needed
        if (isAutoCapitalizeEnabled) {
            // Check if we're at the beginning of a sentence
            val beforeCursor = ic.getTextBeforeCursor(2, 0)
            if (beforeCursor != null && (beforeCursor.isEmpty() || 
                (beforeCursor.length >= 2 && beforeCursor[beforeCursor.length - 2] != '.' && 
                 beforeCursor[beforeCursor.length - 2] != '?' && 
                 beforeCursor[beforeCursor.length - 2] != '!'))) {
                isCapsOn = false
                setupKeyboard()
            }
        }
    }
    
    // AI button implementation moved to the main handleAIButton method below
    
    /**
     * Public methods for settings updates
     */
    
    /**
     * Updates the keyboard theme color
     */
    fun updateThemeColor(colorHex: String) {
        themeColor = colorHex
        preferences.edit().putString(KEY_THEME_COLOR, colorHex).apply()
        
        // Force recreate the keyboard
        Handler(Looper.getMainLooper()).post {
            try {
                // Force recreate input view
                inputView = null
                val newInputView = onCreateInputView()
                setInputView(newInputView)
                
                // Update UI
                updateColors()
                setupKeyboard()
                
                // Force redraw
                newInputView?.invalidate()
                
            } catch (e: Exception) {
                Log.e(TAG, "Error updating theme color: ${e.message}")
                e.printStackTrace()
            }
        }
    }
    
    /**
     * Toggles dark mode
     */
    fun setDarkMode(enabled: Boolean) {
        if (isDarkMode != enabled) {
            isDarkMode = enabled
            preferences.edit().putBoolean(KEY_DARK_MODE, enabled).apply()
            
            // Update colors and keyboard first
            updateColors()
            setupKeyboard()
            
            // Force refresh the UI and suggestion views
            Handler(Looper.getMainLooper()).post {
                try {
                    // Re-initialize suggestion bar with new theme
                    if (::suggestionContainer.isInitialized) {
                        // Save current suggestions
                        val currentSuggestions = this.currentSuggestions.toList()
                        // Re-initialize with new theme
                        initSuggestionBar()
                        // Restore suggestions with new theme
                        updateSuggestions(currentSuggestions)
                    }
                    
                    // Force redraw
                    inputView?.invalidate()
                    inputView?.requestLayout()
                } catch (e: Exception) {
                    Log.e(TAG, "Error updating dark mode: ${e.message}")
                    e.printStackTrace()
                }
            }
        }
    }
    
    /**
     * Toggles haptic feedback
     */
    fun setHapticFeedback(enabled: Boolean) {
        isHapticFeedbackEnabled = enabled
        preferences.edit().putBoolean(KEY_HAPTIC_FEEDBACK, enabled).apply()
    }
    
    /**
     * Toggles auto-capitalization
     */
    fun setAutoCapitalize(enabled: Boolean) {
        isAutoCapitalizeEnabled = enabled
        preferences.edit().putBoolean(KEY_AUTO_CAPITALIZE, enabled).apply()
    }
    
    /**
     * Toggles double-space for period
     */
    fun setDoubleSpacePeriod(enabled: Boolean) {
        isDoubleSpacePeriodEnabled = enabled
        preferences.edit().putBoolean(KEY_DOUBLE_SPACE_PERIOD, enabled).apply()
    }
    
    /**
     * Refreshes the keyboard UI with the latest settings
     */
    fun refreshKeyboard() {
        try {
            // Update settings
            loadSettings()
            
            // Post to main thread for UI updates
            Handler(Looper.getMainLooper()).post {
                try {
                    // Force restart input
                    restartInput()
                    
                    // Update UI
                    updateColors()
                    setupKeyboard()
                    
                    // Force a redraw
                    inputView?.invalidate()
                    
                } catch (e: Exception) {
                    Log.e(TAG, "Error in refreshKeyboard UI update: ${e.message}")
                    e.printStackTrace()
                }
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error in refreshKeyboard: ${e.message}")
            e.printStackTrace()
        }
    }
    
    /**
     * Forces a restart of the input method
     */
    private fun restartInput() {
        try {
            // Save the current input type
            val inputType = currentInputEditorInfo?.inputType ?: 0
            
            // Force recreate the input view
            inputView = null
            val newInputView = onCreateInputView()
            setInputView(newInputView)
            
            // Force input method restart
            onStartInput(currentInputEditorInfo, false)
            onStartInputView(currentInputEditorInfo, false)
            
            // Request focus
            newInputView?.requestFocus()
            
        } catch (e: Exception) {
            Log.e(TAG, "Error in restartInput: ${e.message}")
            e.printStackTrace()
        }
    }
    
    override fun onStartInputView(info: EditorInfo?, restarting: Boolean) {
        val inputType = info?.inputType ?: 0
        isTextOrSearchField = (inputType and InputType.TYPE_MASK_CLASS) == InputType.TYPE_CLASS_TEXT ||
                              (inputType and InputType.TYPE_MASK_VARIATION) == InputType.TYPE_TEXT_VARIATION_WEB_EDIT_TEXT ||
                              (info?.imeOptions ?: 0 and EditorInfo.IME_FLAG_NO_ENTER_ACTION) == 0 // Heuristic for search/text fields
        currentInputEditorInfo = info
        super.onStartInputView(info, restarting)

        val inputTypeLocal = info?.inputType ?: 0 // Renamed to avoid conflict with class member if any
        currentInputTypeSupportsMultiLine = (inputTypeLocal and InputType.TYPE_TEXT_FLAG_IME_MULTI_LINE) != 0

        currentEditorAction = info?.imeOptions?.and(EditorInfo.IME_MASK_ACTION) ?: EditorInfo.IME_ACTION_NONE
        // IME_ACTION_UNSPECIFIED usually means the app hasn't set a specific action, 
        // and the system default (often newline or done based on multi-line flag) is expected.
        // For our logic, if it's unspecified and not multi-line, we might treat it as DONE or let the system decide via performDefaultAction.
        // For now, mapping UNSPECIFIED to NONE simplifies our explicit handling.
        if (currentEditorAction == EditorInfo.IME_ACTION_UNSPECIFIED) { 
            currentEditorAction = EditorInfo.IME_ACTION_NONE
        }
        Log.d(TAG, "onStartInputView: Updated multiLine=$currentInputTypeSupportsMultiLine, action=$currentEditorAction, info?.imeOptions=${info?.imeOptions}, info?.inputType=${info?.inputType}, pkg=${info?.packageName}") // Corrected to use info
        
        // Reset caps lock based on input type
        if (isAutoCapitalizeEnabled) {
            val isCapEnabled = (inputType and EditorInfo.TYPE_TEXT_FLAG_CAP_SENTENCES) != 0 ||
                               (inputType and EditorInfo.TYPE_TEXT_FLAG_CAP_WORDS) != 0 ||
                               (inputType and EditorInfo.TYPE_TEXT_FLAG_CAP_CHARACTERS) != 0
            
            isCapsOn = isCapEnabled
            
            // Update keyboard if it's already shown
            if (inputView != null) {
                setupKeyboard()
            }
        }
        
        // Initialize suggestions if not already done
        if (!::suggestionContainer.isInitialized) {
            initSuggestionBar()
        }
        
        // Clear suggestions when input view is started
        updateSuggestions(emptyList())
        lastInputText = ""
    }
    
    override fun onFinishInput() {
        super.onFinishInput()
        Log.d(TAG, "onFinishInput")
    }
    
    override fun onKeyDown(keyCode: Int, event: KeyEvent?): Boolean {
        val currentInputConnection = currentInputConnection ?: return false
        
        when (keyCode) {
            KeyEvent.KEYCODE_DEL -> {
                handleBackspace(currentInputConnection)
                return true
            }
            KeyEvent.KEYCODE_ENTER -> {
                currentInputConnection.performEditorAction(EditorInfo.IME_ACTION_DONE)
                return true
            }
            KeyEvent.KEYCODE_SPACE -> {
                handleText(" ", true)
                return true
            }
        }
        
        return super.onKeyDown(keyCode, event)
    }
    
    override fun onDestroy() {
        Log.d(TAG, "RewordiumAIKeyboardService destroyed")
        inputView = null
        super.onDestroy()
    }
    
    private fun showToast(message: String) {
        Handler(Looper.getMainLooper()).post {
            Toast.makeText(this, message, Toast.LENGTH_SHORT).show()
        }
    }
    
    /**
     * Initialize the paraphrase view
     */
    private fun initParaphraseView() {
        try {
            // Inflate paraphrase view
            paraphraseView = LayoutInflater.from(this).inflate(R.layout.paraphrase_view, null)
            
            // Set layout parameters for the paraphrase view to match keyboard size
            paraphraseView?.layoutParams = LinearLayout.LayoutParams(
                LinearLayout.LayoutParams.MATCH_PARENT,
                LinearLayout.LayoutParams.WRAP_CONTENT
            )
            
            // Apply background color matching keyboard theme
            paraphraseView?.setBackgroundColor(keyboardBackgroundColor)
            
            // Get references to views
            paraphraseOptionsContainer = paraphraseView?.findViewById(R.id.options_container)
            paraphraseLoadingContainer = paraphraseView?.findViewById(R.id.loading_container)
            originalTextView = paraphraseView?.findViewById(R.id.original_text)
            
            // Get references to option containers and text views
            for (i in 0 until 3) {
                val containerResId = resources.getIdentifier("option_container_${i+1}", "id", packageName)
                val textResId = resources.getIdentifier("option_text_${i+1}", "id", packageName)
                optionContainers[i] = paraphraseView?.findViewById(containerResId)
                optionTextViews[i] = paraphraseView?.findViewById(textResId)
                
                // Set up click listeners for each option container
                optionContainers[i]?.setOnClickListener { 
                    val text = optionTextViews[i]?.text?.toString() ?: ""
                    if (text.isNotEmpty()) {
                        applyParaphrase(text)
                        if (isHapticFeedbackEnabled) {
                            performHapticFeedback()
                        }
                    }
                }
            }
            
            // Set up close button
            val closeButton = paraphraseView?.findViewById<ImageButton>(R.id.btn_close_paraphrase)
            closeButton?.setOnClickListener {
                hideParaphraseView()
            }
            
            // Set layout parameters for the paraphrase view
            val layoutParams = LinearLayout.LayoutParams(
                LinearLayout.LayoutParams.MATCH_PARENT,
                LinearLayout.LayoutParams.WRAP_CONTENT
            )
            paraphraseView?.layoutParams = layoutParams
            
            // Don't add it to the view hierarchy yet - we'll add it when needed
            paraphraseView?.visibility = View.GONE
        } catch (e: Exception) {
            Log.e(TAG, "Error initializing paraphrase view: ${e.message}")
        }
    }
    
    /**
     * Show the paraphrase view
     */
    private fun showParaphraseView(originalText: String) {
        // Save previous keyboard state before switching to paraphrasing
        val previousState = keyboardState
        keyboardState = KeyboardState.PARAPHRASING
        
        // Set the original text
        originalTextView?.text = originalText
        
        // Show loading, hide options
        paraphraseOptionsContainer?.visibility = View.GONE
        paraphraseLoadingContainer?.visibility = View.VISIBLE
        
        // Hide all keyboard components
        numberRow.visibility = View.GONE
        rowQwerty.visibility = View.GONE
        rowAsdf.visibility = View.GONE
        rowZxcv.visibility = View.GONE
        bottomRow.visibility = View.GONE
        
        // Hide emoji keyboard if it's visible
        if (::emojiKeyboardContainer.isInitialized) {
            emojiKeyboardContainer.visibility = View.GONE
        }
        
        // Hide symbols keyboard if it's visible
        if (::symbolsKeyboardContainer.isInitialized) {
            symbolsKeyboardContainer.visibility = View.GONE
        }
        
        // Add paraphrase view to the container if it's not already there
        if (paraphraseView?.parent == null) {
            keyboardContainer.addView(paraphraseView)
        }
        
        // Show paraphrase view
        paraphraseView?.visibility = View.VISIBLE
        
        // Set paraphrasing mode flag
        isParaphrasingMode = true
    }
    
    /**
     * Hide the paraphrase view and restore the previous keyboard layout
     */
    private fun hideParaphraseView() {
        // Hide paraphrase view
        paraphraseView?.visibility = View.GONE
        
        // Remove paraphrase view from container
        if (paraphraseView?.parent == keyboardContainer) {
            keyboardContainer.removeView(paraphraseView)
        }
        
        // Reset paraphrasing mode
        isParaphrasingMode = false
        
        // Always restore to letters keyboard for consistency
        keyboardState = KeyboardState.LETTERS
        setupLettersKeyboard()
        
        // Trigger haptic feedback if enabled
        if (isHapticFeedbackEnabled) {
            performHapticFeedback()
        }
        
        Log.d(TAG, "Paraphrase view hidden, keyboard restored")
    }
    
    /**
     * Updates the paraphrase options in the UI
     */
    private fun updateParaphraseOptions(paraphrases: List<String>) {
        // Hide loading indicator and show options
        paraphraseLoadingContainer?.visibility = View.GONE
        paraphraseOptionsContainer?.visibility = View.VISIBLE
        
        // Update the option text views with paraphrases
        val displayCount = minOf(paraphrases.size, optionTextViews.size)
        
        for (i in 0 until optionTextViews.size) {
            if (i < displayCount) {
                // Set text and make container visible
                optionTextViews[i]?.text = paraphrases[i]
                optionContainers[i]?.visibility = View.VISIBLE
                
                // Set click listener for each option
                optionContainers[i]?.setOnClickListener {
                    applyParaphrase(paraphrases[i])
                    
                    // Trigger haptic feedback if enabled
                    if (isHapticFeedbackEnabled) {
                        performHapticFeedback()
                    }
                }
            } else {
                // Hide unused containers
                optionContainers[i]?.visibility = View.GONE
            }
        }
        // Log the number of paraphrases displayed
        Log.d(TAG, "Displayed $displayCount paraphrase options")
    }
    
    /**
     * Apply the selected paraphrase by replacing the original sentence
     */
    private fun applyParaphrase(text: String) {
        val ic = currentInputConnection ?: return
        val textBeforeCursor = ic.getTextBeforeCursor(1000, 0)?.toString() ?: ""
        
        if (currentSentenceStart >= 0 && currentSentenceStart < textBeforeCursor.length) {
            // Calculate how many characters to delete (the original sentence)
            val deleteLength = textBeforeCursor.length - currentSentenceStart
            
            // Delete the current sentence
            ic.deleteSurroundingText(deleteLength, 0)
            
            // Insert the paraphrased text
            ic.commitText(text, 1)
            
            // Log the replacement
            Log.d(TAG, "Replaced original text with paraphrase: $text")
        } else {
            Log.e(TAG, "Invalid sentence start position: $currentSentenceStart")
        }
        
        // Hide the paraphrase view and return to normal keyboard
        hideParaphraseView()
    }
    
    /**
     * Find the start position of the current sentence in the text
     */
    private fun findSentenceStart(text: String): Int {
        if (text.isEmpty()) return 0
        
        // Find the last occurrence of sentence terminators (period, exclamation, question mark)
        // followed by a space or newline character
        val lastTerminator = maxOf(
            text.lastIndexOf(". "),
            text.lastIndexOf("! "),
            text.lastIndexOf("? "),
            text.lastIndexOf(".\n"),
            text.lastIndexOf("!\n"),
            text.lastIndexOf("?\n")
        )
        
        // Return the position after the terminator, or 0 if no terminator found
        return if (lastTerminator >= 0) lastTerminator + 2 else 0
    }
    
    /**
     * Handles the AI button click to paraphrase the current sentence
     * Uses Groq API with Llama 3 model to generate paraphrases
     */
    private fun handleAIButton() {
        // Trigger haptic feedback if enabled
        if (isHapticFeedbackEnabled) {
            performHapticFeedback()
        }
        
        val ic = currentInputConnection ?: return
        
        // Get the current sentence
        val textBeforeCursor = ic.getTextBeforeCursor(1000, 0)?.toString() ?: ""
        
        // Find the start of the current sentence
        val sentenceStart = findSentenceStart(textBeforeCursor)
        val currentSentence = textBeforeCursor.substring(sentenceStart)
        
        // Skip if sentence is too short
        if (currentSentence.trim().length < 5) {
            showToast("Please type a longer sentence to paraphrase")
            return
        }
        
        Log.d(TAG, "Paraphrasing sentence: $currentSentence")
        
        // Show paraphrase view with loading state
        showParaphraseView(currentSentence)
        
        // Set paraphrasing mode flag and remember sentence start position
        isParaphrasingMode = true
        currentSentenceStart = sentenceStart
        
        // Use coroutine to make API call in background
        CoroutineScope(Dispatchers.Main).launch {
            try {
                // Get paraphrases from Groq API
                val paraphrases = withContext(Dispatchers.IO) {
                    GroqApiClient.getParaphrases(currentSentence)
                }
                
                if (paraphrases.isNotEmpty()) {
                    Log.d(TAG, "Received paraphrases: ${paraphrases.joinToString(", ")}")
                    updateParaphraseOptions(paraphrases)
                } else {
                    Log.e(TAG, "No paraphrases received")
                    hideParaphraseView()
                    showToast("Failed to generate paraphrases")
                }
            } catch (e: Exception) {
                Log.e(TAG, "Error getting paraphrases", e)
                hideParaphraseView()
                showToast("Error: ${e.message}")
            }
        }
    }
    

}
package com.example.yc_startup.keyboard

import android.annotation.SuppressLint
import android.content.Context
import android.content.BroadcastReceiver
import android.content.Intent
import android.content.IntentFilter
import android.content.SharedPreferences
import android.content.res.ColorStateList
import android.graphics.Color
import android.os.Build
import android.graphics.PorterDuff
import android.graphics.PorterDuffColorFilter
import android.graphics.Rect
import android.graphics.Typeface
import android.graphics.Paint as TextPaint
import android.graphics.drawable.GradientDrawable
import android.graphics.drawable.StateListDrawable
import com.example.yc_startup.keyboard.api.GroqApiClient
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import com.example.yc_startup.keyboard.dictionary.SuggestionDictionary
import android.inputmethodservice.InputMethodService
import android.os.Handler
import android.os.Looper
import android.os.SystemClock
import android.os.VibrationEffect
import android.os.Vibrator
import android.text.InputType
import android.text.TextUtils
import android.util.Log
import android.util.TypedValue
import android.view.*
import androidx.core.content.ContextCompat
import android.view.animation.Animation
import android.view.animation.AnimationUtils
import android.widget.Toast
import android.view.animation.DecelerateInterpolator
import android.view.animation.ScaleAnimation
import android.view.inputmethod.EditorInfo
import android.view.inputmethod.InputConnection
import android.view.inputmethod.InputMethodManager
import android.widget.*
import androidx.core.graphics.drawable.DrawableCompat
import com.example.yc_startup.R
import com.example.yc_startup.MainActivity // Added import

private const val TAG = "RewordiumAIKeyboardService"
// PREFS_NAME, ACTION_THEME_UPDATED, KEY_DARK_MODE are now sourced from MainActivity.Companion
private const val KEY_PERSONAS = "keyboard_personas"
private const val KEY_HAPTIC_FEEDBACK = "haptic_feedback"
private const val KEY_AUTO_CAPITALIZE = "auto_capitalize"
private const val KEY_DOUBLE_SPACE_PERIOD = "double_space_period"
private const val SWIPE_THRESHOLD = 50f // Added for spacebar swipe detection

/**
 * A custom iOS-styled keyboard service with AI-powered features
 * that can be customized from the Flutter app settings.
 */
class RewordiumAIKeyboardService : InputMethodService() {

    companion object {
        const val ACTION_PERSONAS_UPDATED = "com.example.yc_startup.keyboard.PERSONAS_UPDATED"
    }
    // UI components
    private var inputView: View? = null
    private lateinit var keyboardContainer: LinearLayout
    private var gifView: pl.droidsonroids.gif.GifImageView? = null
    
    // Suggestion bar components
    private lateinit var suggestionContainer: ViewGroup
    private lateinit var suggestionsTextView: TextView
    private var currentSuggestions: List<String> = emptyList()
    private var currentWord = ""
    private var isParaphrasingMode = false
    private var currentSentenceStart = -1
    private var suggestionWidths: List<Float> = emptyList()
    private var lastClickTime: Long = 0
    private var lastClickPosition: Int = -1
    private var lastInputText: String = ""
    private var lastCursorPosition: Int = 0
    // Use the SuggestionDictionary singleton
    
    // AI button variables
    private lateinit var aiButton: FrameLayout
    
    // Paraphrase variables
    private val paraphraseOptionViews = mutableListOf<TextView>()
    private var originalText = ""
    
    // Persona-based paraphrasing
    private var currentPersona = "Neutral"
    private val availablePersonas = mutableListOf(
        "Neutral", // Always include Neutral as default
        "Happy",
        "Sad",
        "Humor"
    )
    
    // Keyboard rows
    private lateinit var numberRow: LinearLayout
    private lateinit var rowQwerty: LinearLayout
    private lateinit var rowAsdf: LinearLayout
    private lateinit var rowZxcv: LinearLayout
    private lateinit var bottomRow: LinearLayout
    
    // Keyboard state
    private var isCapsOn = false  // Single shift mode (next character capitalized)
    private var isCapsLock = false  // Caps lock mode (all characters capitalized)
    private var isSymbolsShown = false
    private var isEmojiKeyboardShown = false
    private var needsCompleteRefresh = false // Flag to indicate if the keyboard needs to be completely recreated
    private var lastSpaceTime: Long = 0
    private var lastKeyWasSpace = false
    private var lastShiftTime: Long = 0  // For detecting double-tap on shift
    
    // Theme settings
    private var themeColor = "#007AFF" // Default iOS blue
    private var isDarkMode = false
    private var isHapticFeedbackEnabled = true
    private var isAutoCapitalizeEnabled = true
    private var isDoubleSpacePeriodEnabled = true

    // Emoji Keyboard State
    private var currentEmojiCategoryIndex = 0
    private lateinit var emojiKeyboardContainer: FrameLayout // Main container for emoji view, allows overlaying category dots
    private lateinit var emojiGridContainer: LinearLayout // Holds the grid of emojis for the current category
    private lateinit var emojiCategoryTabsContainer: LinearLayout // Holds category selection tabs/icons at the bottom
    private lateinit var emojiCategoryIndicatorContainer: LinearLayout // Holds dots for category indication
    private lateinit var paraphraseContainer: LinearLayout
    private var currentOriginalTextForParaphrase: String? = null

    private val themeUpdateReceiver = object : BroadcastReceiver() {
        override fun onReceive(context: Context?, intent: Intent?) {
            try {
                if (intent?.action == MainActivity.ACTION_THEME_UPDATED) {
                    val prefs = this@RewordiumAIKeyboardService.getSharedPreferences(MainActivity.PREFS_NAME, Context.MODE_PRIVATE)
                    isDarkMode = prefs.getBoolean(MainActivity.KEY_DARK_MODE, false)
                    val themeColor = prefs.getString(MainActivity.KEY_THEME_COLOR, "#007AFF") ?: "#007AFF"
                    Log.d(TAG, "Theme update received, isDarkMode=$isDarkMode, themeColor=$themeColor")
                    
                    // Update all aspects of the keyboard UI
                    forceRefreshKeyboard()
                }
            } catch (e: Exception) {
                Log.e(TAG, "Error in theme update receiver", e)
            }
        }
    }

    private val emojiCategories = listOf(
        "Emoticons" to listOf( // U+1F600 - U+1F64F + Gen Z most-used
    "ðŸ˜­", "ðŸ’€", "ðŸ˜‚", "ðŸ¤£", "ðŸ˜©", "ðŸ˜®â€ðŸ’¨", "ðŸ˜Ž", "ðŸ˜", "ðŸ«¶", "ðŸ¤¡", "ðŸ™„", "ðŸ¥¹", "ðŸ˜¤", "ðŸ¤ ", "ðŸ§", "ðŸ« ", "ðŸ¤™", "ðŸ”¥", "âœ¨", "ðŸ˜¶â€ðŸŒ«ï¸",
    "ðŸ˜€", "ðŸ˜", "ðŸ˜ƒ", "ðŸ˜„", "ðŸ˜…", "ðŸ˜†", "ðŸ˜‡", "ðŸ˜ˆ", "ðŸ˜‰", "ðŸ˜Š", "ðŸ˜‹", "ðŸ˜", "ðŸ˜", "ðŸ˜‘", "ðŸ˜’", "ðŸ˜“", "ðŸ˜”", "ðŸ˜•", "ðŸ˜–", "ðŸ˜—", "ðŸ˜˜",
    "ðŸ˜™", "ðŸ˜š", "ðŸ˜›", "ðŸ˜œ", "ðŸ˜", "ðŸ˜ž", "ðŸ˜Ÿ", "ðŸ˜ ", "ðŸ˜¡", "ðŸ˜¢", "ðŸ˜£", "ðŸ˜¥", "ðŸ˜¦", "ðŸ˜§", "ðŸ˜¨", "ðŸ˜ª", "ðŸ˜«", "ðŸ˜¬", "ðŸ˜®", "ðŸ˜¯", "ðŸ˜°", "ðŸ˜±",
    "ðŸ˜²", "ðŸ˜³", "ðŸ˜´", "ðŸ˜µ", "ðŸ˜¶", "ðŸ˜·", "ðŸ™", "ðŸ™‚", "ðŸ™ƒ", "ðŸ¤", "ðŸ¤‘", "ðŸ¤’", "ðŸ¤“", "ðŸ¤”", "ðŸ¤•", "ðŸ¤—", "ðŸ¤ž", "ðŸ¤¨", "ðŸ¤©", "ðŸ¤ª", "ðŸ¤«", "ðŸ¤¬", "ðŸ¤­",
    "ðŸ¤®", "ðŸ¤¯", "ðŸ§"
),

        "Misc Symbols & Pictographs" to listOf( // U+1F300 - U+1F5FF
            "ðŸŒ", "ðŸŒ‚", "ðŸŒƒ", "ðŸŒ„", "ðŸŒ…", "ðŸŒ†", "ðŸŒ‡", "ðŸŒˆ", "ðŸŒ‰", "ðŸŒŠ", "ðŸŒ‹", "ðŸŒŒ", "ðŸŒ", "ðŸŒŽ", "ðŸŒ", "ðŸŒ", "ðŸŒ‘", "ðŸŒ’", "ðŸŒ“", "ðŸŒ”", "ðŸŒ•", "ðŸŒ–", "ðŸŒ—", "ðŸŒ˜", "ðŸŒ™", "ðŸŒš", "ðŸŒ›", "ðŸŒœ", "ðŸŒ¡ï¸", "â˜€ï¸", "ðŸŒ", "ðŸŒž", "â­", "ðŸŒŸ", "ðŸŒ ",
            "â˜ï¸", "â›…", "â›ˆï¸", "ðŸŒ¤ï¸", "ðŸŒ¥ï¸", "ðŸŒ¦ï¸", "ðŸŒ§ï¸", "ðŸŒ¨ï¸", "ðŸŒ©ï¸", "ðŸŒªï¸", "ðŸŒ«ï¸", "ðŸŒ¬ï¸", "ðŸŒ€", "ðŸ’§", "ðŸ’¦", "ðŸ«§",
            "â˜‚ï¸", "â˜”", "â›±ï¸", "âš¡", "â„ï¸", "â˜ƒï¸", "â›„", "â˜„ï¸", "ðŸ”¥", "ðŸ©¸", "ðŸ‚", "ðŸ", "ðŸ„", "ðŸŒ°", "ðŸŒ±", "ðŸŒ²", "ðŸŒ³", "ðŸŒ´", "ðŸŒµ", "ðŸŒ¶ï¸", "ðŸŒ·", "ðŸŒ¸", "ðŸŒ¹", "ðŸŒº", "ðŸŒ»", "ðŸŒ¼", "ðŸŒ¾", "ðŸŒ¿", "ðŸ€", "ðŸŽ", "ðŸŽ‹", "ðŸƒ",
            "ðŸŽƒ", "ðŸŽ„", "ðŸŽ†", "ðŸŽ‡", "ðŸ§¨", "âœ¨", "ðŸŽˆ", "ðŸŽ‰", "ðŸŽŠ", "ðŸŽ‹", "ðŸŽŒ", "ðŸŽ", "ðŸŽŽ", "ðŸŽ", "ðŸŽ", "ðŸŽ‘", "ðŸ§§", "ðŸŽ€", "ðŸŽ", "ðŸŽ—ï¸", "ðŸŽŸï¸", "ðŸŽ«", "ðŸŽ–ï¸", "ðŸ†", "ðŸ…", "ðŸ¥‡", "ðŸ¥ˆ", "ðŸ¥‰",
            "âš½", "âš¾", "ðŸ¥Ž", "ðŸ€", "ðŸ", "ðŸˆ", "ðŸ‰", "ðŸŽ¾", "ðŸ¸", "ðŸ¥", "ðŸŽ³", "ðŸ", "ðŸ‘", "ðŸ’", "ðŸ¥", "ðŸ“", "â›³", "ðŸª", "ðŸ¹", "ðŸŽ£", "ðŸ¤¿", "ðŸ¥Š", "ðŸ¥‹", "ðŸŽ½", "ðŸ›¹", "ðŸ›¼", "ðŸ›·", "â›¸ï¸", "ðŸ¥Œ", "ðŸŽ¿",
            "ðŸŽ¯", "ðŸŽ±", "ðŸ”®", "ðŸª„", "ðŸ§¿", "ðŸŽ®", "ðŸ•¹ï¸", "ðŸŽ°", "ðŸŽ²", "ðŸ§©", "ðŸ§¸", "ðŸª…", "ðŸª†", "ðŸ–¼ï¸", "ðŸŽ¨", "ðŸ§µ", "ðŸª¡", "ðŸ§¶", "ðŸª¢",
            "ðŸ‘“", "ðŸ•¶ï¸", "ðŸ¥½", "ðŸ¥¼", "ðŸ¦º", "ðŸ‘”", "ðŸ‘•", "ðŸ‘–", "ðŸ§£", "ðŸ§¤", "ðŸ§¥", "ðŸ§¦", "ðŸ‘—", "ðŸ‘˜", "ðŸ¥»", "ðŸ©±", "ðŸ©²", "ðŸ©³", "ðŸ‘™", "ðŸ‘š", "ðŸ‘›", "ðŸ‘œ", "ðŸ‘", "ðŸŽ’", "ðŸ‘ž", "ðŸ‘Ÿ", "ðŸ¥¾", "ðŸ¥¿", "ðŸ‘ ", "ðŸ‘¡", "ðŸ©°", "ðŸ‘¢",
            "ðŸ‘‘", "ðŸ‘’", "ðŸŽ©", "ðŸŽ“", "ðŸ§¢", "â›‘ï¸", "ðŸ’„", "ðŸ’", "ðŸ’¼"
        ),
        "Transport & Map" to listOf( // U+1F680 - U+1F6FF
            "ðŸš€", "ðŸš", "ðŸš‚", "ðŸšƒ", "ðŸš„", "ðŸš…", "ðŸš†", "ðŸš‡", "ðŸšˆ", "ðŸš‰", "ðŸšŠ", "ðŸš‹", "ðŸšŒ", "ðŸš", "ðŸšŽ", "ðŸš", "ðŸš", "ðŸš‘", "ðŸš’", "ðŸš“", "ðŸš”", "ðŸš•", "ðŸš–", "ðŸš—", "ðŸš˜", "ðŸš™", "ðŸ›»", "ðŸšš", "ðŸš›", "ðŸšœ",
            "ðŸŽï¸", "ðŸï¸", "ðŸ›µ", "ðŸ¦½", "ðŸ¦¼", "ðŸ›º", "ðŸš²", "ðŸ›´", "ðŸ›¹", "ðŸ›¼", "ðŸ›°ï¸", "ðŸ›¸", "ðŸ›¶", "â›µ", "ðŸš¤", "ðŸ›¥ï¸", "ðŸ›³ï¸", "â›´ï¸", "ðŸš¢", "âœˆï¸", "ðŸ›©ï¸", "ðŸ›«", "ðŸ›¬", "ðŸª‚", "ðŸ’º",
            "â›½", "ðŸš§", "ðŸš¦", "ðŸš¥", "ðŸ›‘", "ðŸ", "ðŸš©", "ðŸŽŒ", "ðŸ´", "ðŸ³ï¸", "ðŸ³ï¸â€ðŸŒˆ", "ðŸ³ï¸â€âš§ï¸", "âš“", "ðŸ—ºï¸", "ðŸ§­"
        ),
        "Misc Symbols" to listOf( // U+2600 - U+26FF
            "â˜€", "â˜", "â˜‚", "â˜ƒ", "â˜„", "â˜…", "â˜†", "â˜‡", "â˜ˆ", "â˜‰", "â˜Š", "â˜‹", "â˜Œ", "â˜", "â˜Ž", "â˜", "â˜", "â˜‘", "â˜’", "â˜“", "â˜”", "â˜•", "â˜˜ï¸", "â˜ ï¸", "â˜¢ï¸", "â˜£ï¸", "â˜¦ï¸", "â˜ªï¸", "â˜®ï¸", "â˜¯ï¸", "â˜¸ï¸", "â˜¹ï¸", "â˜ºï¸",
            "â™€ï¸", "â™‚ï¸", "â™ˆ", "â™‰", "â™Š", "â™‹", "â™Œ", "â™", "â™Ž", "â™", "â™", "â™‘", "â™’", "â™“", "â™Ÿï¸", "â™ ï¸", "â™£ï¸", "â™¥ï¸", "â™¦ï¸", "â™¨ï¸", "â™»ï¸", "â™¾ï¸", "â™¿", "âš’ï¸", "âš“", "âš”ï¸", "âš•ï¸", "âš–ï¸", "âš—ï¸", "âš™ï¸", "âš›ï¸", "âšœï¸",
            "âš ï¸", "âš¡", "âšª", "âš«", "âš½", "âš¾", "â›„", "â›…", "â›ˆï¸", "â›Ž", "â›ï¸", "â›‘ï¸", "â›“ï¸", "â›”", "â›©ï¸", "â›ª", "â›°ï¸", "â›±ï¸", "â›²", "â›³", "â›´ï¸", "â›µ", "â›·ï¸", "â›¸ï¸", "â›¹ï¸â€â™€ï¸", "â›¹ï¸", "â›¹ï¸â€â™‚ï¸", "â›º", "â›½"
        ),
        "Dingbats" to listOf( // U+2700 - U+27BF
            "âœ€", "âœ", "âœ‚", "âœƒ", "âœ„", "âœ…", "âœ†", "âœ‡", "âœˆ", "âœ‰", "âœŠ", "âœ‹", "âœŒ", "âœ", "âœŽ", "âœ", "âœ", "âœ‘", "âœ’", "âœ”", "âœ•", "âœ–", "âœ—", "âœ˜", "âœ™", "âœš", "âœ›", "âœœ", "âœï¸", "âœž", "âœŸ", "âœ ", "âœ¡ï¸", "â˜¸ï¸",
            "âœï¸", "âœŒï¸", "â˜ï¸", "ðŸ––", "ðŸ–ï¸", "ðŸ–•", "ðŸ¤³", "ðŸ’…", "ðŸ‘„", "ðŸ¦·", "ðŸ‘…", "ðŸ‘‚", "ðŸ‘ƒ", "ðŸ‘ï¸", "ðŸ‘€", "ðŸ§ ", "ðŸ¦´", "ðŸ—£ï¸", "ðŸ‘¤", "ðŸ‘¥", "ðŸ«‚"
        ),
        "Supplemental Symbols" to listOf( // U+1F900 - U+1F9FF
            "ðŸ¤°", "ðŸ¤±", "ðŸ¤²", "ðŸ§ ", "ðŸ§¡", "ðŸ§¢", "ðŸ§£", "ðŸ§¤", "ðŸ§¥", "ðŸ§¦", "ðŸ§§", "ðŸ§¨", "ðŸ§©", "ðŸ§ª", "ðŸ§«", "ðŸ§¬", "ðŸ§­", "ðŸ§®", "ðŸ§¯", "ðŸ§°", "ðŸ§±",
            "ðŸª‘", "ðŸª’", "ðŸª“", "ðŸª”", "ðŸª•", "ðŸª–", "ðŸª—", "ðŸª˜", "ðŸª™", "ðŸªš", "ðŸª›", "ðŸªœ", "ðŸª", "ðŸªž", "ðŸªŸ", "ðŸª ", "ðŸª¤", "ðŸª£", "ðŸª¥", "ðŸª¦", "ðŸª§", "ðŸª¨", "ðŸªµ", "ðŸ›–",
            "ðŸª±", "ðŸª°", "ðŸª²", "ðŸª³", "ðŸª´", "ðŸª¶", "ðŸ¦°", "ðŸ¦±", "ðŸ¦²", "ðŸ¦³", "ðŸ¦´", "ðŸ¦µ", "ðŸ¦¶", "ðŸ¦·", "ðŸ¦¸", "ðŸ¦¹", "ðŸ¦º", "ðŸ¦»", "ðŸ¦¼", "ðŸ¦½", "ðŸ¦¾", "ðŸ¦¿",
            "ðŸ§€", "ðŸ§", "ðŸ§‚", "ðŸ¥£", "ðŸ¥¤", "ðŸ¥¥", "ðŸ¥¦", "ðŸ¥­", "ðŸ¥®", "ðŸ¥¯", "ðŸ¥°", "ðŸ¥±", "ðŸ¥²", "ðŸ¥¸", "ðŸ¥³", "ðŸ¥´", "ðŸ¥µ", "ðŸ¥¶", "ðŸ¥º", "ðŸ¥»", "ðŸ¥¼", "ðŸ¥½", "ðŸ¥¾", "ðŸ¥¿"
        ),
        "Symbols Extended-A" to listOf( // U+1FA70 - U+1FAFF
            "ðŸª€", "ðŸª", "ðŸª‚", "ðŸªƒ", "ðŸª„", "ðŸª…", "ðŸª†", "ðŸª", "ðŸª‘", "ðŸª’", "ðŸª“", "ðŸª”", "ðŸª•", "ðŸª–", "ðŸª—", "ðŸª˜", "ðŸª™", "ðŸªš", "ðŸª›", "ðŸªœ", "ðŸª", "ðŸªž", "ðŸªŸ", "ðŸª ", "ðŸª¤", "ðŸª£", "ðŸª¥", "ðŸª¦", "ðŸª§", "ðŸª¨",
            "ðŸªµ", "ðŸ›–", "ðŸª±", "ðŸª°", "ðŸª²", "ðŸª³", "ðŸª´", "ðŸª¶", "ðŸ«€", "ðŸ«", "ðŸ«‚", "ðŸ«ƒ", "ðŸ«„", "ðŸ«…", "ðŸ«–", "ðŸ«—", "ðŸ«˜", "ðŸ«™", "ðŸ«š", "ðŸ«›", "ðŸ«œ", "ðŸ«", "ðŸ«ž", "ðŸ«Ÿ", "ðŸ« ", "ðŸ«¡"
        )
        // Regional Indicator Symbols (flags) are omitted for now due to complexity and number.
    )

    // Constants for emoji grid layout
    private val EMOJI_COLUMNS = 8 // Number of emojis per row in the grid
    private val EMOJI_ROWS = 4    // Number of emoji rows to display per page/category view

    // Keyboard colors
    private var keyBackgroundColor = 0
    private var keyTextColor = 0
    private var specialKeyBackgroundColor = 0
    private var keyboardBackgroundColor = 0
    
    // Shared preferences for settings
    private lateinit var preferences: SharedPreferences

    // Turbo delete variables
    private val deleteHandler = Handler(Looper.getMainLooper())
    private lateinit var deleteRunnable: Runnable
    private var isDeleting = false
    private var deleteCount = 0
    private val initialDeleteDelay = 500L // ms before starting repeat
    private val repeatDeleteDelay = 80L // ms between deletes in normal mode
    private val turboDeleteDelay = 30L // ms between deletes in turbo mode
    private val maxDeletesBeforeTurbo = 8 // number of deletes before switching to turbo speed
    private val wordDeleteDelay = 3000L // 3 seconds to hold for word delete
    private var wordDeleteRunnable: Runnable? = null
    private var isWordDeleteActive = false
    private var isTextOrSearchField: Boolean = false // Added for spacebar swipe logic
    private var currentEditorAction: Int = EditorInfo.IME_ACTION_NONE
    private var currentInputTypeSupportsMultiLine: Boolean = false
    private var currentInputEditorInfo: EditorInfo? = null
    
    // Key popup
    private var keyPopup: PopupWindow? = null
    private var currentPopupKey: View? = null

    private lateinit var personaUpdateReceiver: BroadcastReceiver

    override fun onCreate() {
        super.onCreate()
        Log.d(TAG, "RewordiumAIKeyboardService created")
        
        // Load preferences
        val prefs = getSharedPreferences(MainActivity.PREFS_NAME, Context.MODE_PRIVATE)
        themeColor = prefs.getString(MainActivity.KEY_THEME_COLOR, "#007AFF") ?: "#007AFF"
        isDarkMode = prefs.getBoolean(MainActivity.KEY_DARK_MODE, false)
        isHapticFeedbackEnabled = prefs.getBoolean(KEY_HAPTIC_FEEDBACK, true)
        isAutoCapitalizeEnabled = prefs.getBoolean(KEY_AUTO_CAPITALIZE, true) 
        isDoubleSpacePeriodEnabled = prefs.getBoolean(KEY_DOUBLE_SPACE_PERIOD, true)
        
        // Load keyboard personas from preferences
        val savedPersonas = prefs.getString("keyboard_personas", null)
        Log.d(TAG, "[Service onCreate] Read from SharedPreferences: '$savedPersonas'")
        if (!savedPersonas.isNullOrEmpty()) {
            updateKeyboardPersonas(savedPersonas.split(","))
            // Log inside updateKeyboardPersonas will show the result
        } else {
            Log.d(TAG, "[Service onCreate] No saved personas, using defaults or letting updateKeyboardPersonas handle it.")
            updateKeyboardPersonas(listOf()) // Ensure it processes defaults
        }
        
        // Initialize theme colors
        updateColors()

        // Initialize and register persona update receiver
        personaUpdateReceiver = object : BroadcastReceiver() {
            override fun onReceive(context: Context?, intent: Intent?) {
                try {
                    if (intent?.action == MainActivity.ACTION_PERSONAS_UPDATED) {
                        Log.d(TAG, "Received persona update broadcast")
                        // Reload personas from SharedPreferences
                        val prefs = getSharedPreferences(MainActivity.PREFS_NAME, Context.MODE_PRIVATE)
                        val savedPersonas = prefs.getString("keyboard_personas", null)
                        Log.d(TAG, "[Service Receiver] Read from SharedPreferences: '$savedPersonas'")
                        if (!savedPersonas.isNullOrEmpty()) {
                            updateKeyboardPersonas(savedPersonas.split(","))
                            // Log inside updateKeyboardPersonas will show the result
                            
                            // If paraphrase view is active, refresh it
                            if (isParaphrasingMode && currentOriginalTextForParaphrase != null) {
                                Log.d(TAG, "[Service Receiver] Paraphrase view is active, calling showParaphraseView.")
                                showParaphraseView(currentOriginalTextForParaphrase!!)
                            }
                            
                            // Force UI refresh to show the persona changes immediately
                            forceRefreshKeyboard()
                        } else {
                            Log.d(TAG, "[Service Receiver] No saved personas found after broadcast, using defaults.")
                            updateKeyboardPersonas(listOf()) // Fallback to defaults
                        }
                    }
                } catch (e: Exception) {
                    Log.e(TAG, "Error in persona update receiver", e)
                }
            }
        }
        val personasFilter = IntentFilter(MainActivity.ACTION_PERSONAS_UPDATED)
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            registerReceiver(personaUpdateReceiver, personasFilter, Context.RECEIVER_NOT_EXPORTED)
        } else {
            registerReceiver(personaUpdateReceiver, personasFilter)
        }


        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            registerReceiver(themeUpdateReceiver, IntentFilter(MainActivity.ACTION_THEME_UPDATED), Context.RECEIVER_NOT_EXPORTED)
        } else {
            registerReceiver(themeUpdateReceiver, IntentFilter(MainActivity.ACTION_THEME_UPDATED))
        }
        Log.d(TAG, "Theme and Persona update receivers registered.")
    }
    
    /**
     * Updates color scheme based on current settings
     */
    private fun updateColors() {
        try {
            val themeColorInt = Color.parseColor(themeColor)
            
            if (isDarkMode) {
                // Dark mode colors
                keyBackgroundColor = Color.parseColor("#333333")
                keyTextColor = Color.WHITE
                specialKeyBackgroundColor = Color.parseColor("#333333")
                // Set iOS-style dark keyboard background
                if (keyboardContainer != null) {
                    keyboardContainer.setBackgroundColor(Color.parseColor("#1C1C1E"))
                }
            } else {
                // Light mode colors (iOS style)
                keyBackgroundColor = Color.parseColor("#FFFFFF")
                keyTextColor = Color.BLACK
                specialKeyBackgroundColor = Color.parseColor("#D1D1D6")
                // Set iOS-style light keyboard background
                if (keyboardContainer != null) {
                    keyboardContainer.setBackgroundColor(Color.parseColor("#D1D1D6"))
                }
            }
            
            // Apply the colors immediately if we have a view
            if (inputView != null) {
                Handler(Looper.getMainLooper()).post {
                    applyThemeColors()
                }
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error updating colors: ${e.message}")
            e.printStackTrace()
        }
    }
    
    /**
     * Updates the AI button colors based on the current theme
     */
    private fun setupAIButton() {
        try {
            val aiButton = inputView?.findViewById<android.widget.FrameLayout>(R.id.ai_button) ?: return
            // Use the class-level gifView variable directly instead of creating a local variable
            gifView = inputView?.findViewById<pl.droidsonroids.gif.GifImageView>(R.id.ai_animation) ?: return
            
            // Set up the GIF view
            try {
                // The GIF is already set in the XML layout using android:src
                // Just make sure it's set to loop and has transparent background
                gifView?.setBackgroundColor(Color.TRANSPARENT)
                
                // Track initial touch coordinates
                val touchSlop = ViewConfiguration.get(applicationContext).scaledTouchSlop
                var touchDownX = 0f
                var touchDownY = 0f
                
                // Set up touch listener on the parent to handle haptics and animation
                aiButton.setOnTouchListener { v, event ->
                    when (event.action) {
                        MotionEvent.ACTION_DOWN -> {
                            // Store initial touch coordinates
                            touchDownX = event.rawX
                            touchDownY = event.rawY
                            // Visual feedback
                            v.alpha = 0.7f
                            true
                        }
                        MotionEvent.ACTION_UP -> {
                            v.alpha = 1.0f
                            
                            // Only trigger action if user didn't move their finger too much
                            if (Math.abs(event.rawX - touchDownX) < touchSlop.toFloat() && 
                                Math.abs(event.rawY - touchDownY) < touchSlop.toFloat()) {
                                // Handle AI button click
                                Log.d(TAG, "AI button clicked")
                                
                                // Restart the animation
                                val gifDrawable = gifView?.drawable as? pl.droidsonroids.gif.GifDrawable
                                gifDrawable?.seekTo(0)
                                gifDrawable?.start()
                                
                                // Trigger haptic feedback if enabled
                                if (isHapticFeedbackEnabled) {
                                    performHapticFeedback()
                                }
                                
                                // Handle AI button action
                                handleAIButton()
                            }
                            true
                        }
                        MotionEvent.ACTION_CANCEL -> {
                            v.alpha = 1.0f
                            true
                        }
                        else -> false
                    }
                }
                
            } catch (e: Exception) {
                Log.e(TAG, "Error setting up GIF: ${e.message}")
            }
            
            // Set click listener for AI button
            aiButton.setOnClickListener {
                try {
                    // Handle AI button click
                    Log.d(TAG, "AI button clicked")
                    
                    // Restart the animation
                    gifView?.let { gif ->
                        val gifDrawable = gif.drawable as? pl.droidsonroids.gif.GifDrawable
                        gifDrawable?.seekTo(0)
                        gifDrawable?.start()
                    }
                    
                    // Trigger haptic feedback if enabled
                    if (isHapticFeedbackEnabled) {
                        performHapticFeedback()
                    }
                    
                    // Handle AI button action
                    handleAIButton()
                    
                } catch (e: Exception) {
                    Log.e(TAG, "Error in AI button click: ${e.message}")
                }
            }
            
        } catch (e: Exception) {
            Log.e(TAG, "Error setting up AI button: ${e.message}")
            e.printStackTrace()
        }
    }
    
    override fun onCreateInputView(): View {
        Log.d(TAG, "Creating input view")
        try {
            inputView = LayoutInflater.from(this).inflate(R.layout.ios_keyboard_layout, null)
            keyboardContainer = inputView?.findViewById(R.id.keyboard_container) ?: throw IllegalStateException("Keyboard container not found")
            
            // Initialize keyboard rows first
            numberRow = inputView?.findViewById(R.id.number_row) ?: throw IllegalStateException("Number row not found")
            rowQwerty = inputView?.findViewById(R.id.row_qwerty) ?: throw IllegalStateException("QWERTY row not found")
            rowAsdf = inputView?.findViewById(R.id.row_asdfghjkl) ?: throw IllegalStateException("ASDF row not found")
            rowZxcv = inputView?.findViewById(R.id.row_zxcvbnm) ?: throw IllegalStateException("ZXCV row not found")
            bottomRow = inputView?.findViewById(R.id.bottom_row) ?: throw IllegalStateException("Bottom row not found")
            
            // Initialize suggestion bar
            initSuggestionBar()
            
            // Initialize paraphrase view
            initParaphraseView()
            
            // Initialize keyboard buttons
            setupKeyboardButtons()
            
            // Apply theme colors
            applyThemeColors()
            
            // Setup keyboard layout
            setupKeyboard()
            
            return inputView!!
        } catch (e: Exception) {
            Log.e(TAG, "Error creating input view: ${e.message}")
            e.printStackTrace()
            // Return a simple view to prevent crashes
            return TextView(this).apply {
                text = "Error loading keyboard"
                gravity = Gravity.CENTER
                setTextColor(Color.BLACK)
                setBackgroundColor(Color.WHITE)
            }
        }
    }
    
    /**
     * Initializes the suggestion bar components
     */
    private fun initSuggestionBar() {
        try {
            suggestionContainer = inputView?.findViewById(R.id.suggestion_container) 
                ?: throw IllegalStateException("Suggestion container not found")
            
            // Initialize the single text view for all suggestions
            suggestionsTextView = inputView?.findViewById(R.id.suggestions_text)
                ?: throw IllegalStateException("Suggestions text view not found")
            
            // Set text color based on theme
            suggestionsTextView.setTextColor(Color.parseColor("#007AFF")) // iOS blue
            
            // Set click listener for the suggestions text view
            setupSuggestionClicks()
            
            // Initially hide suggestions
            updateSuggestions(emptyList())
        } catch (e: Exception) {
            Log.e(TAG, "Error initializing suggestion bar: ${e.message}")
            // If we can't initialize the suggestion bar, make sure we don't crash
            suggestionContainer.visibility = View.GONE
            throw e
        }
    }
    
    private fun setupSuggestionClicks() {
        // Set up touch listener for the entire suggestions text view
        suggestionsTextView.setOnTouchListener { view, event ->
            when (event.action) {
                MotionEvent.ACTION_DOWN -> {
                    val x = event.x
                    val viewWidth = view.width.toFloat()
                    
                    // Divide the suggestion bar into 3 equal parts
                    val partWidth = viewWidth / 3
                    
                    // Determine which part was tapped (0, 1, or 2)
                    val partIndex = (x / partWidth).toInt().coerceIn(0, 2)
                    
                    // If we have a suggestion at this position, select it
                    if (partIndex < currentSuggestions.size) {
                        onSuggestionTapped(currentSuggestions[partIndex])
                        return@setOnTouchListener true
                    }
                }
            }
            false
        }
    }
    
    /**
     * Handles clicks on the suggestion text view
     */
    private fun onSuggestionTapped(suggestion: String) {
        // Only commit the tapped suggestion if it's not empty
        if (suggestion.isNotEmpty()) {
            val ic = currentInputConnection ?: return
            
            // Handle differently based on whether we're in paraphrasing mode
            if (isParaphrasingMode) {
                // Get the text before cursor to replace the current sentence
                val textBeforeCursor = ic.getTextBeforeCursor(1000, 0)?.toString() ?: ""
                
                if (currentSentenceStart >= 0 && currentSentenceStart < textBeforeCursor.length) {
                    // Delete the current sentence
                    val deleteLength = textBeforeCursor.length - currentSentenceStart
                    ic.deleteSurroundingText(deleteLength, 0)
                    
                    // Insert the selected paraphrase
                    ic.commitText(suggestion, 1)
                    
                    // Reset paraphrasing mode
                    isParaphrasingMode = false
                    currentSentenceStart = 0
                }
            } else {
                // Regular word suggestion mode
                // Get the text before the cursor
                val textBeforeCursor = ic.getTextBeforeCursor(100, 0)?.toString() ?: ""
                
                // Find the start of the current word
                val wordStart = textBeforeCursor.takeLastWhile { it.isLetterOrDigit() || it == '\'' }.length
                
                // Delete the current word if there is one
                if (wordStart > 0) {
                    ic.deleteSurroundingText(wordStart, 0)
                }
                
                // Insert the selected suggestion with a space
                ic.commitText("$suggestion ", 1)
                
                // Clear the current word buffer
                currentWord = ""
            }
            
            // Clear suggestions after selection
            updateSuggestions(emptyList())
            
            // Trigger haptic feedback if enabled
            if (isHapticFeedbackEnabled) {
                performHapticFeedback()
            }
            
            try {
                // No-op, just to keep the try-catch structure
            } catch (e: Exception) {
                Log.e(TAG, "Error committing text: ${e.message}")
            }
        }
    }
    
    /**
     * Updates the suggestion bar with new suggestions
     */
    private fun updateSuggestions(suggestions: List<String>) {
        currentSuggestions = suggestions.take(3) // Only take first 3 suggestions
        
        if (currentSuggestions.isEmpty()) {
            suggestionsTextView.visibility = View.GONE
            return
        }
        
        // Reset text size to default before measuring
        val defaultTextSize = 16f // Default size in SP
        suggestionsTextView.textSize = defaultTextSize
        
        // Get display metrics
        val displayMetrics = resources.displayMetrics
        val screenWidth = displayMetrics.widthPixels.toFloat()
        val partWidth = screenWidth / 5
        val divider = " | "
        val dividerWidth = suggestionsTextView.paint.measureText(divider)
        
        // Create a list to hold the formatted suggestions
        val formattedSuggestions = mutableListOf<String>()
        
        // Process each suggestion to ensure it fits in its part
        currentSuggestions.forEachIndexed { index, suggestion ->
            val paint = suggestionsTextView.paint
            var currentSuggestion = suggestion
            
            // Calculate maximum width for this suggestion (part width minus half of divider on each side)
            val maxSuggestionWidth = partWidth - dividerWidth
            
            // Measure the text width
            var textWidth = paint.measureText(currentSuggestion)
            
            // If text is too wide, try to fit it
            if (textWidth > maxSuggestionWidth) {
                // First try to reduce the text size
                val scale = (maxSuggestionWidth / textWidth) * 0.95f // 95% to be safe
                val newSize = defaultTextSize * scale
                
                if (newSize >= 10f) { // Don't go below 10sp
                    paint.textSize = newSize * displayMetrics.scaledDensity
                    textWidth = paint.measureText(currentSuggestion)
                    
                    // If still too wide, truncate with ellipsis
                    if (textWidth > maxSuggestionWidth) {
                        currentSuggestion = truncateTextWithEllipsis(
                            paint, 
                            currentSuggestion, 
                            maxSuggestionWidth
                        )
                    }
                } else {
                    // Text is still too wide, force truncation
                    currentSuggestion = truncateTextWithEllipsis(
                        paint, 
                        currentSuggestion, 
                        maxSuggestionWidth
                    )
                }
                
                // Reset paint text size
                paint.textSize = defaultTextSize * displayMetrics.scaledDensity
            }
            
            // Center the text in its part
            val padding = (partWidth - paint.measureText(currentSuggestion)) / 2
            val space = " ".repeat((padding / paint.measureText(" ")).toInt())
            formattedSuggestions.add("$space$currentSuggestion$space")
        }
        
        // Ensure we have exactly 3 parts (even if some are empty)
        while (formattedSuggestions.size < 3) {
            formattedSuggestions.add("")
        }
        
        // Join with dividers and set the text
        val suggestionsText = "${formattedSuggestions[0]} | ${formattedSuggestions[1]} | ${formattedSuggestions[2]}"
        
        // Set the text and make visible
        suggestionsTextView.text = suggestionsText.trim()
        suggestionsTextView.visibility = View.VISIBLE
        suggestionsTextView.gravity = Gravity.CENTER
    }
    
    private fun truncateTextWithEllipsis(paint: TextPaint, text: String, maxWidth: Float): String {
        if (paint.measureText(text) <= maxWidth) return text
        
        val ellipsis = "..."
        val ellipsisWidth = paint.measureText(ellipsis)
        val availableWidth = maxWidth - ellipsisWidth.toFloat()
        
        var left = 0
        var right = text.length
        var mid: Int
        
        // Binary search for the maximum length that fits
        while (left < right) {
            mid = (left + right) / 2
            val width = paint.measureText(text, 0, mid)
            
            if (width < availableWidth) {
                left = mid + 1
            } else {
                right = mid - 1
            }
        }
        
        // Ensure we don't go out of bounds
        val end = (left - 1).coerceAtLeast(0)
        return "${text.substring(0, end)}$ellipsis"
    }
    
    private fun generateSuggestions(text: String): List<String> {
        if (text.isEmpty()) return emptyList()
        
        // Get the current word being typed (last word in the text)
        val currentWord = text.split("\\s").lastOrNull()?.lowercase() ?: return emptyList()
        
        // Get suggestions from our dictionary
        return SuggestionDictionary.getSuggestions(currentWord, this@RewordiumAIKeyboardService)
    }
    
    /**
     * Updates suggestions based on current input
     */
    private fun updateSuggestionsFromInput() {
        val ic = currentInputConnection ?: return
        
        // Get text before cursor
        val textBeforeCursor = ic.getTextBeforeCursor(100, 0)?.toString() ?: ""
        val textAfterCursor = ic.getTextAfterCursor(100, 0)?.toString() ?: ""
        
        // Only update if text has changed
        if (textBeforeCursor == lastInputText && textAfterCursor.isEmpty()) return
        
        lastInputText = textBeforeCursor
        
        // Get current word
        val currentWord = textBeforeCursor.split("\\s").lastOrNull() ?: ""
        
        // Generate and update suggestions
        val suggestions = generateSuggestions(currentWord)
        updateSuggestions(suggestions)
    }
    
    private fun applyThemeColors() {
        try {
            // Get the root layout
            val rootLayout = inputView?.findViewById<View>(R.id.root_keyboard_layout)
            
            // Set root layout background color based on theme
            val bgColor = if (isDarkMode) {
                Color.parseColor("#1C1C1E") // Dark background
            } else {
                Color.parseColor("#D1D1D6") // Light background (matching iOS style)
            }
            
            // Apply colors to all relevant views
            rootLayout?.setBackgroundColor(bgColor)
            keyboardContainer?.setBackgroundColor(bgColor)
            
            // Update top bar background color
            val topBar = inputView?.findViewById<View>(R.id.top_bar_container)
            topBar?.setBackgroundColor(bgColor)
            
            // Update suggestion container background
            suggestionContainer?.setBackgroundColor(Color.TRANSPARENT)
            
            // Force update suggestion view if initialized
            if (::suggestionsTextView.isInitialized) {
                // Ensure text color is always iOS blue
                suggestionsTextView.setTextColor(Color.parseColor("#007AFF"))
                
                // Force redraw the suggestion container
                suggestionsTextView.invalidate()
                suggestionsTextView.requestLayout()
            }
            
            // Update keyboard container padding area
            keyboardContainer?.setPaddingRelative(
                keyboardContainer?.paddingStart ?: 0,
                keyboardContainer?.paddingTop ?: 0,
                keyboardContainer?.paddingEnd ?: 0,
                keyboardContainer?.paddingBottom ?: 0
            )
            
            // Set up AI button with current theme
            setupAIButton()
            
        } catch (e: Exception) {
            Log.e(TAG, "Error applying theme colors: ${e.message}")
            e.printStackTrace()
        }
    }
    
    /**
     * Handles text input with support for double-space for period functionality
     */
    private fun handleText(text: String, enableHaptic: Boolean = true) {
        val ic = currentInputConnection ?: return
        
        // Update suggestions after text input
        Handler(Looper.getMainLooper()).postDelayed({
            updateSuggestionsFromInput()
        }, 50) // Small delay to ensure text is committed
        
        // Handle double-space for period if enabled
        if (isDoubleSpacePeriodEnabled && text == " ") {
            val currentTime = System.currentTimeMillis()
            
            // Check if this is a double-space (within 500ms of previous space)
            if (currentTime - lastSpaceTime < 500 && lastKeyWasSpace) {
                // Delete the previous space
                ic.deleteSurroundingText(1, 0)
                // Add period + space
                ic.commitText(". ", 1)
                
                // Clear suggestions after period
                updateSuggestions(emptyList())
                
                // Provide haptic feedback for the second space tap if enabled
                if (isHapticFeedbackEnabled && enableHaptic) {
                    performHapticFeedback()
                }

                // Enable caps for next character
                if (isAutoCapitalizeEnabled) {
                    isCapsOn = true
                    setupKeyboard()
                }
                
                lastKeyWasSpace = false
                lastSpaceTime = 0 // Reset the timer
                return
            }
            
            lastKeyWasSpace = true
            lastSpaceTime = currentTime
        } else {
            // Reset the space timer for any non-space character
            lastKeyWasSpace = false
            lastSpaceTime = 0
            
            // Auto-capitalize after sentence endings if enabled
            if (isAutoCapitalizeEnabled && text in listOf(".", "!", "?")) {
                isCapsOn = true
                setupKeyboard()
            }
        }
        
        // Commit the text
        ic.commitText(text, 1)
        
        // Turn off shift (but not caps lock) after typing a character or space
        if (isCapsOn && !isCapsLock && text != "") {
            isCapsOn = false
            setupKeyboard()
        }
        
        // Provide haptic feedback if enabled
        if (isHapticFeedbackEnabled && enableHaptic) {
            performHapticFeedback()
        }
    }
    
    /**
     * Performs haptic feedback for key presses
     */
    private fun performHapticFeedback() {
        try {
            // Try to use view haptic feedback first
            inputView?.performHapticFeedback(
                HapticFeedbackConstants.KEYBOARD_TAP,
                HapticFeedbackConstants.FLAG_IGNORE_GLOBAL_SETTING
            )
        } catch (e: Exception) {
            // Fall back to vibrator service
            try {
                val vibrator = getSystemService(Context.VIBRATOR_SERVICE) as? Vibrator
                vibrator?.let {
                    if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.O) {
                        it.vibrate(VibrationEffect.createOneShot(10, VibrationEffect.DEFAULT_AMPLITUDE))
                    } else {
                        @Suppress("DEPRECATION")
                        it.vibrate(10)
                    }
                }
            } catch (e: Exception) {
                Log.e(TAG, "Error performing haptic feedback: ${e.message}")
            }
        }
    }
    
    private fun setupKeyboardButtons() {
        try {
            // Set up AI button with WebM animation
            setupAIButton()
        } catch (e: Exception) {
            Log.e(TAG, "Error setting up AI button: ${e.message}")
            e.printStackTrace()
        }
        
        // Rows are now initialized in onCreateInputView
        if (numberRow == null || rowQwerty == null || rowAsdf == null || rowZxcv == null || bottomRow == null) {
            Log.e(TAG, "Keyboard rows not properly initialized")
            throw IllegalStateException("Keyboard rows not properly initialized")
        }
    }
    
    /**
     * Sets up the keyboard layout based on current state
     */
    private fun setupKeyboard() {
        try {
            Log.d(TAG, "setupKeyboard called. States: isEmojiKeyboardShown=$isEmojiKeyboardShown, isSymbolsShown=$isSymbolsShown, isCapsOn=$isCapsOn, isCapsLock=$isCapsLock")
            
            // Check if rows are properly initialized
            if (numberRow == null || rowQwerty == null || rowAsdf == null || rowZxcv == null || bottomRow == null) {
                Log.e(TAG, "Keyboard rows not initialized, initializing now")
                setupKeyboardButtons()
                if (numberRow == null || rowQwerty == null || rowAsdf == null || rowZxcv == null || bottomRow == null) {
                    throw IllegalStateException("Failed to initialize keyboard rows")
                }
            }
            
            // Clear existing views
            numberRow.removeAllViews()
            rowQwerty.removeAllViews()
            rowAsdf.removeAllViews()
            rowZxcv.removeAllViews()
            bottomRow.removeAllViews()
        } catch (e: Exception) {
            Log.e(TAG, "Error in setupKeyboard: ${e.message}")
            e.printStackTrace()
            throw e
        }
        
        when {
            isEmojiKeyboardShown -> setupEmojiKeyboard()
            isSymbolsShown -> setupSymbolsKeyboard()
            else -> setupLettersKeyboard()
        }
    }
    
    private fun setupLettersKeyboard() {
    Log.d(TAG, "setupLettersKeyboard called. States: isCapsOn=$isCapsOn, isCapsLock=$isCapsLock")
        // Add number row
        for (char in "1234567890") {
            addKey(numberRow, char.toString()) { handleText(char.toString()) }
        }
        
        // Add QWERTY row
        val qwertyRow = if (isCapsOn) "QWERTYUIOP" else "qwertyuiop"
        for (char in qwertyRow) {
            addKey(rowQwerty, char.toString()) { handleText(char.toString()) }
        }
        
        // Add left padding to ASDF row without creating an actual key
        val leftPadding = View(this)
        val paddingParams = LinearLayout.LayoutParams(
            0, 
            resources.getDimensionPixelSize(R.dimen.ios_key_height),
            0.5f
        )
        rowAsdf.addView(leftPadding, paddingParams)
        
        val asdfRow = if (isCapsOn) "ASDFGHJKL" else "asdfghjkl"
        for (char in asdfRow) {
            addKey(rowAsdf, char.toString()) { handleText(char.toString()) }
        }
        
        // Add right padding after 'L' key
        val rightPadding = View(this)
        val rightPaddingParams = LinearLayout.LayoutParams(
            0, 
            resources.getDimensionPixelSize(R.dimen.ios_key_height),
            0.5f
        )
        rowAsdf.addView(rightPadding, rightPaddingParams)
        
        // No backspace key here anymore - moved to bottom row
        
        // Add ZXCV row
        // Add shift key
        val shiftIconRes = when {
            isCapsLock -> R.drawable.ic_shift_caps_lock  // Use special icon with underscore for caps lock
            isCapsOn -> R.drawable.ic_shift_filled      // Regular filled icon for shift
            else -> R.drawable.ic_shift                 // Outline icon for normal state
        }
        val shiftKey = addSpecialKey(rowZxcv, "", shiftIconRes, 2.0f) {
            toggleCapsLock()
        }
        
        // Apply special styling to shift key based on state
        // Create a custom drawable for the shift key that respects the theme
        val shiftDrawable = GradientDrawable().apply {
            cornerRadius = TypedValue.applyDimension(
                TypedValue.COMPLEX_UNIT_DIP,
                6f,
                resources.displayMetrics
            )
            // Set the default background color (will be overridden by state colors)
            setColor(if (isDarkMode) specialKeyBackgroundColor else keyBackgroundColor)
        }
        shiftKey.background = shiftDrawable
        // Ensure the shift key has proper padding like other keys
        shiftKey.setPadding(0, 10, 0, 0)
        
        // Set state for proper background color
        if (shiftKey is Button) {
            // Use tag to track state since isActivated/isChecked might not be available
            shiftKey.tag = if (isCapsLock) 2 else if (isCapsOn) 1 else 0
            
            // Apply different background tint based on state and dark mode
            val stateColor = when {
                isCapsLock -> Color.parseColor(themeColor) // Theme color for caps lock (same in both modes)
                isCapsOn -> if (isDarkMode) Color.parseColor("#555555") else Color.GRAY // Lighter gray in dark mode
                else -> if (isDarkMode) specialKeyBackgroundColor else keyBackgroundColor // Use theme colors for normal state
            }
            
            val drawable = shiftKey.background.mutate()
            DrawableCompat.setTint(drawable, stateColor)
            
            // Set icon color to white for caps lock mode and add indicator
            if (shiftKey is ImageButton) {
                if (isCapsLock) {
                    // Set icon to white for caps lock
                    shiftKey.colorFilter = PorterDuffColorFilter(Color.WHITE, PorterDuff.Mode.SRC_IN)
                    
                    // Add a visual indicator for caps lock (a small dot)
                    val capsLockIndicator = View(this)
                    val indicatorSize = resources.getDimensionPixelSize(R.dimen.caps_lock_indicator_size)
                    val params = FrameLayout.LayoutParams(indicatorSize, indicatorSize)
                    params.gravity = Gravity.TOP or Gravity.END
                    params.setMargins(0, 5, 5, 0)
                    
                    // Create a circular background
                    val indicatorDrawable = GradientDrawable().apply {
                        shape = GradientDrawable.OVAL
                        setColor(Color.WHITE)
                    }
                    capsLockIndicator.background = indicatorDrawable
                    
                    // First remove any existing indicator to avoid duplicates
                    // Cast to View first to resolve ambiguity
                    val shiftKeyView = shiftKey as View
                    if (shiftKeyView.parent is ViewGroup) {
                        val parent = shiftKeyView.parent as ViewGroup
                        for (i in 0 until parent.childCount) {
                            val child = parent.getChildAt(i)
                            if (child.tag == "caps_lock_indicator") {
                                parent.removeView(child)
                                break
                            }
                        }
                        
                        // Add the new indicator
                        capsLockIndicator.tag = "caps_lock_indicator"
                        parent.addView(capsLockIndicator, params)
                    }
                } else {
                    // Clear icon color for other states
                    shiftKey.clearColorFilter()
                    
                    // Remove the indicator if it exists
                    // Cast to View first to resolve ambiguity
                    val shiftKeyView = shiftKey as View
                    if (shiftKeyView.parent is ViewGroup) {
                        val parent = shiftKeyView.parent as ViewGroup
                        for (i in 0 until parent.childCount) {
                            val child = parent.getChildAt(i)
                            if (child.tag == "caps_lock_indicator") {
                                parent.removeView(child)
                                break
                            }
                        }
                    }
                }
            }
            
            // Increase text size for better visibility
            shiftKey.textSize = 30f
            shiftKey.typeface = android.graphics.Typeface.DEFAULT_BOLD
            shiftKey.setPadding(0, 10, 0, 0) // Better vertical centering
        }
        
        val zxcvRow = if (isCapsOn) "ZXCVBNM" else "zxcvbnm"
        for (char in zxcvRow) {
            addKey(rowZxcv, char.toString()) { handleText(char.toString()) }
        }
        
        // Add backspace key with turbo delete and word delete
        val backspaceKey = addSpecialKey(rowZxcv, "", R.drawable.ic_backspace, 1.5f) { /* onClick is overridden by setOnTouchListener */ }
        
        // Apply the same background as shift key
        val backspaceDrawable = GradientDrawable().apply {
            cornerRadius = TypedValue.applyDimension(
                TypedValue.COMPLEX_UNIT_DIP,
                6f,
                resources.displayMetrics
            )
            setColor(specialKeyBackgroundColor)
        }
        backspaceKey.background = backspaceDrawable
        if (backspaceKey is ImageButton) {
            backspaceKey.setPadding(0, 10, 0, 0)
        }
        
        backspaceKey.setOnTouchListener { v, event ->
            val ic = currentInputConnection ?: return@setOnTouchListener false
            
            when (event.action) {
                MotionEvent.ACTION_DOWN -> {
                    // Visual feedback
                    v.alpha = 0.7f
                    
                    // Start word delete timer
                    wordDeleteRunnable = Runnable {
                        isWordDeleteActive = true
                        // Strong haptic for word delete initiation
                        if (isHapticFeedbackEnabled) {
                            v.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS)
                        }
                        handleBackspace(ic, true)
                    }
                    deleteHandler.postDelayed(wordDeleteRunnable!!, wordDeleteDelay)
                    
                    // Initial delete
                    handleBackspace(ic)
                    
                    // Start turbo delete sequence
                    isDeleting = true
                    deleteCount = 0
                    
                    deleteRunnable = object : Runnable {
                        override fun run() {
                            if (isDeleting) {
                                handleBackspace(ic, isWordDeleteActive)
                                deleteCount++
                                val delay = if (deleteCount >= 5) 30L else repeatDeleteDelay // Turbo delete improved
                                deleteHandler.postDelayed(this, delay)
                            }
                        }
                    }
                    
                    // Start repeating deletes after initial delay
                    deleteHandler.postDelayed(deleteRunnable, initialDeleteDelay)
                    
                    true
                }
                
                MotionEvent.ACTION_UP, MotionEvent.ACTION_CANCEL -> {
                    // Clean up
                    isDeleting = false
                    isWordDeleteActive = false
                    wordDeleteRunnable?.let { deleteHandler.removeCallbacks(it) }
                    deleteHandler.removeCallbacks(deleteRunnable)
                    
                    // Reset visual state
                    v.alpha = 1.0f
                    // v.performClick() // Removed to prevent potential '?' issue
                    
                    true
                }
                
                else -> false
            }
        }
        
        // Add bottom row
        // Numbers key
        addSpecialKey(bottomRow, "123", null, 1.5f, true) {
            if (isHapticFeedbackEnabled) performHapticFeedback()
            isSymbolsShown = true
            setupKeyboard()
        }
        
        // Globe key (language)
        addSpecialKey(bottomRow, "", R.drawable.ic_globe, 1f) {
            // Would show language options
            Log.d(TAG, "Globe key pressed")
        }
        
        // Space bar with swipe navigation
        val spaceKey = addKey(bottomRow, "space", 0, 5f, false, true) {
            handleText(" ")
        }
        
        // Apply iOS-style appearance to spacebar
        if (spaceKey is Button) {
            // Create a custom drawable for the spacebar that respects the theme
            val spacebarDrawable = GradientDrawable().apply {
                cornerRadius = TypedValue.applyDimension(
                    TypedValue.COMPLEX_UNIT_DIP,
                    6f,
                    resources.displayMetrics
                )
                // Use the appropriate background color based on dark mode
                setColor(if (isDarkMode) specialKeyBackgroundColor else keyBackgroundColor)
            }
            spaceKey.background = spacebarDrawable
            spaceKey.textSize = 16f
            spaceKey.setTextColor(keyTextColor)
            
            // Variables for tracking swipe
            var startX = 0f
            val swipeThreshold = 20 // Minimum pixels to consider it a swipe
            var isSwiping = false
            
            spaceKey.setOnTouchListener { v, event ->
                // Check if we're in a text or search field
                val editorInfo = currentInputEditorInfo
                val inputType = editorInfo?.inputType ?: 0
                val isTextOrSearchField = when (inputType and InputType.TYPE_MASK_CLASS) {
                    InputType.TYPE_CLASS_TEXT -> true
                    InputType.TYPE_CLASS_NUMBER -> true
                    else -> false
                }
                
                when (event.action) {
                    MotionEvent.ACTION_DOWN -> {
                        startX = event.rawX
                        isSwiping = false
                        v.alpha = 0.7f // Visual feedback
                        true
                    }
                    MotionEvent.ACTION_MOVE -> {
                        // Only enable swipe in text/search fields
                        if (!isTextOrSearchField) return@setOnTouchListener false
                        
                        val deltaX = event.rawX - startX
                        if (Math.abs(deltaX.toFloat()) > swipeThreshold) {
                            isSwiping = true
                            // Move cursor left or right based on swipe direction
                            val keyCode = if (deltaX > 0) KeyEvent.KEYCODE_DPAD_RIGHT else KeyEvent.KEYCODE_DPAD_LEFT
                            val eventTime = SystemClock.uptimeMillis()
                            
                            // Send key events for cursor movement
                            currentInputConnection?.sendKeyEvent(KeyEvent(
                                eventTime, eventTime,
                                KeyEvent.ACTION_DOWN, keyCode, KeyEvent.META_CTRL_ON
                            ))
                            currentInputConnection?.sendKeyEvent(KeyEvent(
                                eventTime, eventTime,
                                KeyEvent.ACTION_UP, keyCode, 0
                            ))
                            
                            // Update startX for continuous movement
                            startX = event.rawX
                            
                            // Haptic feedback for better UX
                            if (isHapticFeedbackEnabled) {
                                v.performHapticFeedback(HapticFeedbackConstants.VIRTUAL_KEY)
                            }
                            return@setOnTouchListener true
                        }
                        false
                    }
                    MotionEvent.ACTION_UP -> {
                        v.alpha = 1.0f // Reset visual state
                        if (!isSwiping) {
                            // Only insert space if it wasn't a swipe
                            handleText(" ")
                        }
                        true
                    }
                    MotionEvent.ACTION_CANCEL -> {
                        v.alpha = 1.0f // Reset visual state
                        true
                    }
                    else -> false
                }
            }
        }
        // First Emoji Key Implementation (setupLettersKeyboard method)
// Replace lines 609-613 with this:
// Emoji key
addSpecialKey(bottomRow, "", R.drawable.ic_emoji, 1f) {
    if (isHapticFeedbackEnabled) performHapticFeedback()
    isEmojiKeyboardShown = !isEmojiKeyboardShown
    isSymbolsShown = false
    setupKeyboard()
    Log.d(TAG, "Emoji key pressed, emoji keyboard shown: $isEmojiKeyboardShown")
}
        
        // Create a custom button for return key - based on the working implementation from symbols layout
        val returnKey = Button(this).apply { // Changed from TextView to Button for better sizing
            text = "return"
            textSize = 10f // Reduced from 12f to prevent wrapping
            setAllCaps(false) // Prevent all-caps text transformation
            gravity = Gravity.CENTER
            setTextColor(Color.WHITE)
            maxLines = 1 // Ensure text stays on one line
            ellipsize = TextUtils.TruncateAt.END // Add ellipsis if text is too long
            
            // Use consistent padding to ensure proper height and text placement
            val paddingHorizDp = TypedValue.applyDimension(
                TypedValue.COMPLEX_UNIT_DIP, 
                4f, // Reduced from 8f to give more space for text
                resources.displayMetrics
            ).toInt()
            
            val paddingVerticalDp = TypedValue.applyDimension(
                TypedValue.COMPLEX_UNIT_DIP,
                2f, // Small vertical padding
                resources.displayMetrics
            ).toInt()
            
            setPadding(paddingHorizDp, paddingVerticalDp, paddingHorizDp, paddingVerticalDp)
            
            // Blue background
            val bgDrawable = GradientDrawable().apply {
                cornerRadius = TypedValue.applyDimension(
                    TypedValue.COMPLEX_UNIT_DIP,
                    6f,
                    resources.displayMetrics
                )
                setColor(Color.parseColor(themeColor)) // Use theme color
            }
            background = bgDrawable
            
            // Set layout parameters - increased weight for better fit
            layoutParams = LinearLayout.LayoutParams(0, ViewGroup.LayoutParams.MATCH_PARENT, 1.5f).apply {
                // Minimal margins to maximize size
                val marginDp = TypedValue.applyDimension(
                    TypedValue.COMPLEX_UNIT_DIP,
                    3f,
                    resources.displayMetrics
                ).toInt()
                setMargins(marginDp, marginDp, marginDp, marginDp)
            }
            
            // Set click listener - using the EXACT SAME logic that works in the symbols layout
            setOnClickListener {
                val ic = currentInputConnection ?: return@setOnClickListener // Get current input connection
                if (isHapticFeedbackEnabled) performHapticFeedback() // Perform haptic feedback if enabled

                Log.d(TAG, "QWERTY Return: multiLine=$currentInputTypeSupportsMultiLine, action=$currentEditorAction")
                
                // Check if the current input field supports multiple lines
                if (currentInputTypeSupportsMultiLine) { 
                    // If yes (e.g., messaging, notes), insert a newline character
                    ic.commitText("\n", 1) 
                } else { 
                    // If no (e.g., browser search bar, single-line input)
                    // Check if a specific editor action is defined (like Search, Go, Send)
                    if (currentEditorAction != EditorInfo.IME_ACTION_NONE) { 
                        // If yes, perform that specific action
                        ic.performEditorAction(currentEditorAction) 
                    } else { 
                        // If no specific action is defined, send a standard Enter key press
                        val eventTime = SystemClock.uptimeMillis()
                        ic.sendKeyEvent(KeyEvent(eventTime, eventTime, KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_ENTER, 0))
                        ic.sendKeyEvent(KeyEvent(eventTime, eventTime, KeyEvent.ACTION_UP, KeyEvent.KEYCODE_ENTER, 0))
                    }
                }
            }
        }
        
        // Add the return key to the bottom row
        bottomRow.addView(returnKey) // End of if (returnKey is Button)
    } // End of setupLettersKeyboard() method
    
    private fun setupSymbolsKeyboard() {
        // Add number row
        for (char in "1234567890") {
            addKey(numberRow, char.toString()) { handleText(char.toString()) }
        }
        
        // Add symbols rows
        for (char in "-/:;()$&@\"") {
            addKey(rowQwerty, char.toString()) { handleText(char.toString()) }
        }
        
        // Add middle row with useful symbols (no empty keys)
        // Use gravity to ensure proper spacing
        rowAsdf.gravity = Gravity.CENTER_HORIZONTAL

        // Add commonly used symbols that were missing from the layout
        // Added symbols: period, comma, question mark, exclamation, apostrophe, asterisk, percentage, underscore, caret, tilde
        for (char in ".,?!'*%_^~") {
            addKey(rowAsdf, char.toString(), 0, 1f) { handleText(char.toString()) }
        }
        
        // Add bottom symbols row
        addSpecialKey(rowZxcv, "#+=", null, 1.5f, true) {
            // Would show more symbols
            Log.d(TAG, "More symbols key pressed")
        }
        
        for (char in "[]{}<>") {
            addKey(rowZxcv, char.toString()) { handleText(char.toString()) }
        }
        
        // Replace return key next to '>' with backspace key with turbo delete
        val backspaceKey = addSpecialKey(rowZxcv, "", R.drawable.ic_backspace, 1.5f) { 
            // The onClick is overridden by the setOnTouchListener below
        }
        
        // Add turbo delete with word deletion on long press
        backspaceKey.setOnTouchListener { v, event ->
            val ic = currentInputConnection ?: return@setOnTouchListener false
            when (event.action) {
                MotionEvent.ACTION_DOWN -> {
                    v.alpha = 0.7f // Visual feedback for press
                    isDeleting = true
                    deleteCount = 0
                    handleBackspace(ic) // Initial delete
                    
                    // Start checking for long press after 3 seconds
                    deleteHandler.postDelayed({
                        if (isDeleting) {
                            // Delete entire word
                            val wordToDelete = ic.getTextBeforeCursor(100, 0)?.toString()
                            if (!wordToDelete.isNullOrEmpty()) {
                                val lastSpace = wordToDelete.lastIndexOf(' ')
                                val charsToDelete = if (lastSpace == -1) {
                                    wordToDelete.length
                                } else {
                                    wordToDelete.length - lastSpace - 1
                                }
                                
                                if (charsToDelete > 0) {
                                    ic.deleteSurroundingText(charsToDelete, 0)
                                    if (isHapticFeedbackEnabled) {
                                        v.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS)
                                    }
                                }
                            }
                        }
                    }, 3000) // 3 second delay for word delete

                    deleteRunnable = Runnable {
                        if (isDeleting) {
                            handleBackspace(ic)
                            deleteCount++
                            val delay = if (deleteCount >= maxDeletesBeforeTurbo) turboDeleteDelay else repeatDeleteDelay
                            deleteHandler.postDelayed(deleteRunnable, delay)
                        }
                    }
                    deleteHandler.postDelayed(deleteRunnable, initialDeleteDelay)
                    true
                }
                MotionEvent.ACTION_UP, MotionEvent.ACTION_CANCEL -> {
                    isDeleting = false
                    deleteHandler.removeCallbacks(deleteRunnable)
                    // Also remove the long press callback
                    deleteHandler.removeCallbacksAndMessages(null)
                    v.alpha = 1.0f // Reset visual feedback
                    true
                }
                else -> false
            }
        }
        
        // Add bottom row
        // ABC key
        addSpecialKey(bottomRow, "ABC", null, 1.5f, true) {
            if (isHapticFeedbackEnabled) performHapticFeedback()
            isSymbolsShown = false
            setupKeyboard()
        }
        
        // Globe key (language)
        addSpecialKey(bottomRow, "", R.drawable.ic_globe, 1f) {
            // Would show language options
            Log.d(TAG, "Globe key pressed")
        }
        
        // Space bar with slightly reduced width
        // Space bar with swipe navigation for Symbols Keyboard
    var localSymbolsSpaceStartX = 0f // Captured by the listener lambda
    var localSymbolsSpaceIsSwiping = false // Captured by the listener lambda
    val spaceKeySymbols = addKey(bottomRow, "space", 0, 4f, false, true) { 
        // Tap action is now primarily handled by the OnTouchListener's ACTION_UP.
        // This onClick can be an empty lambda or a fallback.
        // handleText(" ", true) // Redundant if OnTouchListener handles tap reliably.
    }
    spaceKeySymbols.setOnTouchListener { v, event ->
        val ic = currentInputConnection ?: return@setOnTouchListener false

        when (event.action) {
            MotionEvent.ACTION_DOWN -> {
                localSymbolsSpaceStartX = event.rawX
                localSymbolsSpaceIsSwiping = false
                // Haptic on press for tap is handled by handleText in ACTION_UP.
                // For swipe initiation, this provides immediate feedback.
                if (isHapticFeedbackEnabled) v.performHapticFeedback(HapticFeedbackConstants.VIRTUAL_KEY)
                v.alpha = 0.7f
                true
            }
            MotionEvent.ACTION_MOVE -> {
                if (!isTextOrSearchField) return@setOnTouchListener false // Only allow swipe in text fields
                val deltaX = event.rawX - localSymbolsSpaceStartX
                if (Math.abs(deltaX.toFloat()) > SWIPE_THRESHOLD) { // SWIPE_THRESHOLD is a class member
                    localSymbolsSpaceIsSwiping = true
                    val keyCode = if (deltaX > 0) KeyEvent.KEYCODE_DPAD_RIGHT else KeyEvent.KEYCODE_DPAD_LEFT
                    val eventTime = SystemClock.uptimeMillis()
                    ic.sendKeyEvent(KeyEvent(eventTime, eventTime, KeyEvent.ACTION_DOWN, keyCode, KeyEvent.META_CTRL_ON))
                    ic.sendKeyEvent(KeyEvent(eventTime, eventTime, KeyEvent.ACTION_UP, keyCode, 0))
                    localSymbolsSpaceStartX = event.rawX // Update for continuous movement
                    if (isHapticFeedbackEnabled) {
                        v.performHapticFeedback(HapticFeedbackConstants.VIRTUAL_KEY) // Haptic for each swipe segment
                    }
                    return@setOnTouchListener true // Consume the event as it's a swipe action
                }
                false // Not a swipe significant enough to act upon yet
            }
            MotionEvent.ACTION_UP -> {
                v.alpha = 1.0f // Reset visual feedback
                if (!localSymbolsSpaceIsSwiping) {
                    // If not a swipe, treat as a tap.
                    handleText(" ", true) // Perform space insertion and haptic feedback.
                }
                // Reset swipe state for the next touch operation
                localSymbolsSpaceIsSwiping = false 
                true // Consume the event
            }
            MotionEvent.ACTION_CANCEL -> {
                v.alpha = 1.0f // Reset visual feedback
                localSymbolsSpaceIsSwiping = false
                true // Consume the event
            }
            else -> false // Don't consume other actions
        }
    }
        
        // Second Emoji Key Implementation (setupSymbolsKeyboard method)
// Replace lines 798-801 with this:
// Emoji key
addSpecialKey(bottomRow, "", R.drawable.ic_emoji, 1f) {
    if (isHapticFeedbackEnabled) performHapticFeedback()
    isEmojiKeyboardShown = !isEmojiKeyboardShown
    isSymbolsShown = false
    setupKeyboard()
    Log.d(TAG, "Emoji key pressed, emoji keyboard shown: $isEmojiKeyboardShown")
}
        
        // Custom styled blue return key with exact height match to emoji key
        val returnKey = Button(this).apply { // Changed from TextView to Button for better sizing
            text = "return"
            textSize = 10f // Reduced from 12f to prevent wrapping
            setAllCaps(false) // Prevent all-caps text transformation
            gravity = Gravity.CENTER
            setTextColor(Color.WHITE)
            maxLines = 1 // Ensure text stays on one line
            ellipsize = TextUtils.TruncateAt.END // Add ellipsis if text is too long
            
            // Use consistent padding to ensure proper height and text placement
            val paddingHorizDp = TypedValue.applyDimension(
                TypedValue.COMPLEX_UNIT_DIP, 
                4f, // Reduced from 8f to give more space for text
                resources.displayMetrics
            ).toInt()
            
            val paddingVerticalDp = TypedValue.applyDimension(
                TypedValue.COMPLEX_UNIT_DIP,
                2f, // Small vertical padding
                resources.displayMetrics
            ).toInt()
            
            setPadding(paddingHorizDp, paddingVerticalDp, paddingHorizDp, paddingVerticalDp)
            
            // Blue background
            val bgDrawable = GradientDrawable().apply {
                cornerRadius = TypedValue.applyDimension(
                    TypedValue.COMPLEX_UNIT_DIP,
                    6f,
                    resources.displayMetrics
                )
                setColor(Color.parseColor("#007AFF")) // iOS blue color
            }
            background = bgDrawable
            
            // Set layout parameters - increased weight for better fit
            layoutParams = LinearLayout.LayoutParams(0, ViewGroup.LayoutParams.MATCH_PARENT, 2f).apply {
                // Minimal margins to maximize size
                val marginDp = TypedValue.applyDimension(
                    TypedValue.COMPLEX_UNIT_DIP,
                    3f,
                    resources.displayMetrics
                ).toInt()
                setMargins(marginDp, marginDp, marginDp, marginDp)
            }
            
                        // Set click listener
                        setOnClickListener {
                            val ic = currentInputConnection ?: return@setOnClickListener // Get current input connection
                            if (isHapticFeedbackEnabled) performHapticFeedback() // Perform haptic feedback if enabled
            
                            // Check if the current input field supports multiple lines
                            if (currentInputTypeSupportsMultiLine) { 
                                // If yes (e.g., messaging, notes), insert a newline character
                                ic.commitText("\n", 1) 
                            } else { 
                                // If no (e.g., browser search bar, single-line input)
                                // Check if a specific editor action is defined (like Search, Go, Send)
                                if (currentEditorAction != EditorInfo.IME_ACTION_NONE) { 
                                    // If yes, perform that specific action
                                    ic.performEditorAction(currentEditorAction) 
                                } else { 
                                    // If no specific action is defined, send a standard Enter key press
                                    val eventTime = SystemClock.uptimeMillis()
                                    ic.sendKeyEvent(KeyEvent(eventTime, eventTime, KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_ENTER, 0))
                                    ic.sendKeyEvent(KeyEvent(eventTime, eventTime, KeyEvent.ACTION_UP, KeyEvent.KEYCODE_ENTER, 0))
                                }
                            }
                        }
        }
        bottomRow.addView(returnKey)
    }
    
    /**
     * Sets up the emoji keyboard layout
     */

    // Populates the emoji grid with emojis from the current category
    private fun populateEmojiGrid() {
        emojiGridContainer.removeAllViews() // Clear previous emojis

        if (currentEmojiCategoryIndex < 0 || currentEmojiCategoryIndex >= emojiCategories.size) {
            Log.e(TAG, "Invalid emoji category index: $currentEmojiCategoryIndex")
            return
        }

        val (_, emojis) = emojiCategories[currentEmojiCategoryIndex]
        var emojiCounter = 0
        // val totalEmojisInPage = EMOJI_ROWS * EMOJI_COLUMNS // Not strictly needed for this simple version

        for (i in 0 until EMOJI_ROWS) {
            val rowLayout = LinearLayout(this).apply {
                orientation = LinearLayout.HORIZONTAL
                layoutParams = LinearLayout.LayoutParams(
                    LinearLayout.LayoutParams.MATCH_PARENT,
                    LinearLayout.LayoutParams.WRAP_CONTENT // Height will be determined by keys
                )
            }
            for (j in 0 until EMOJI_COLUMNS) {
                if (emojiCounter < emojis.size) {
                    val emoji = emojis[emojiCounter]
                    addKey(rowLayout, emoji, weight = 1f) { handleText(emoji) }
                    emojiCounter++
                } else {
                    // Add an empty placeholder view to maintain grid structure
                    val emptyView = View(this)
                    // Ensure empty view takes up space and has a defined height (e.g., key height)
                    val params = LinearLayout.LayoutParams(0, dpToPx(55), 1f) 
                    emptyView.layoutParams = params
                    rowLayout.addView(emptyView)
                }
            }
            emojiGridContainer.addView(rowLayout)
        }
        updateEmojiCategoryIndicator() // Update dots after populating grid
    }

    // Updates the category indicator dots
    private fun updateEmojiCategoryIndicator() {
        emojiCategoryIndicatorContainer.removeAllViews()
        for (i in emojiCategories.indices) {
            val dot = View(this).apply {
                layoutParams = LinearLayout.LayoutParams(dpToPx(8), dpToPx(8)).apply {
                    setMargins(dpToPx(4), dpToPx(4), dpToPx(4), dpToPx(4)) // Added some vertical margin for dots
                }
                val shape = GradientDrawable().apply {
                    shape = GradientDrawable.OVAL
                    setColor(if (i == currentEmojiCategoryIndex) Color.parseColor(themeColor) else Color.LTGRAY)
                    setSize(dpToPx(8), dpToPx(8))
                }
                background = shape
            }
            emojiCategoryIndicatorContainer.addView(dot)
        }
    }

    // Creates the category selection tabs (or buttons)
    private fun createEmojiCategoryTabs() {
        emojiCategoryTabsContainer.removeAllViews()
        // Using representative emojis for category tabs. Could be replaced with icons.
        val categoryTabRepresentations = listOf("ðŸ˜€", "ðŸŽ¨", "ðŸš—", "â­", "âœ‚ï¸", "ðŸ§©", "ðŸª") 

        for (i in emojiCategories.indices) {
            val (categoryName, _) = emojiCategories[i]
            // Use predefined representation or fallback to first char of category name
            val tabRepresentation = categoryTabRepresentations.getOrElse(i) { categoryName.firstOrNull()?.toString() ?: "?" }

            val tabButton = Button(this).apply {
                text = tabRepresentation
                layoutParams = LinearLayout.LayoutParams(0, LinearLayout.LayoutParams.MATCH_PARENT, 1f)
                // Style similar to other special keys
                setTextSize(TypedValue.COMPLEX_UNIT_SP, 22f) // Emoji font size for tab
                setBackgroundColor(Color.TRANSPARENT) // Or use specialKeyBackgroundColor if defined and suitable
                setTextColor(keyTextColor) // Use keyboard's text color
                setPadding(dpToPx(2), dpToPx(2), dpToPx(2), dpToPx(2)) // Minimal padding

                setOnClickListener {
                    if (isHapticFeedbackEnabled) performHapticFeedback()
                    if (currentEmojiCategoryIndex != i) {
                        currentEmojiCategoryIndex = i
                        populateEmojiGrid() // This will also call updateEmojiCategoryIndicator
                    }
                }
            }
            emojiCategoryTabsContainer.addView(tabButton)
        }
    }

    // Variables for swipe detection on the emoji grid
    private var emojiGridSwipeInitialX = 0f
    // Using the existing SWIPE_THRESHOLD constant for consistency

    // Sets up swipe detection for the emoji grid container
    @SuppressLint("ClickableViewAccessibility")
    private fun setupEmojiSwipeDetection() {
        emojiGridContainer.setOnTouchListener { _, event -> // v is unused, replaced with _
            when (event.action) {
                MotionEvent.ACTION_DOWN -> {
                    emojiGridSwipeInitialX = event.x
                    true // Consume the event to handle swipe
                }
                MotionEvent.ACTION_MOVE -> {
                    // Must return true if ACTION_DOWN returned true and you want to receive ACTION_MOVE/UP.
                    true
                }
                MotionEvent.ACTION_UP -> {
                    val deltaX = event.x - emojiGridSwipeInitialX
                    var swiped = false
                    if (Math.abs(deltaX) > SWIPE_THRESHOLD) { // Use existing SWIPE_THRESHOLD
                        if (deltaX < 0) { // Swiped Left (next category)
                            currentEmojiCategoryIndex = (currentEmojiCategoryIndex + 1) % emojiCategories.size
                        } else { // Swiped Right (previous category)
                            currentEmojiCategoryIndex = (currentEmojiCategoryIndex - 1 + emojiCategories.size) % emojiCategories.size
                        }
                        if (isHapticFeedbackEnabled) performHapticFeedback()
                        populateEmojiGrid() // This also updates indicators
                        swiped = true
                    }
                    // If swiped, event is consumed. Otherwise, child views (emoji keys) handle their own taps.
                    swiped 
                }
                else -> false // For other actions, don't consume
            }
        }
    }

private fun setupEmojiKeyboard() {
    Log.d(TAG, "setupEmojiKeyboard called. Initial state: isEmojiKeyboardShown=$isEmojiKeyboardShown, isSymbolsShown=$isSymbolsShown")
    keyboardContainer.removeAllViews() // Clear the main container for a fresh emoji keyboard setup

    // Initialize the main emoji keyboard container (FrameLayout for potential layering, e.g., pop-ups)
    emojiKeyboardContainer = FrameLayout(this).apply {
        layoutParams = FrameLayout.LayoutParams(
            FrameLayout.LayoutParams.MATCH_PARENT,
            FrameLayout.LayoutParams.MATCH_PARENT
        )
        // Consider setting background color if keyboardContainer doesn't provide one
        // or if a distinct emoji panel background is desired.
        // setBackgroundColor(keyboardBackgroundColor) 
    }

    // Vertical LinearLayout to hold the grid, indicators, tabs, and bottom controls
    val emojiMainLayout = LinearLayout(this).apply {
        orientation = LinearLayout.VERTICAL
        layoutParams = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.MATCH_PARENT,
            LinearLayout.LayoutParams.MATCH_PARENT
        )
    }

    // 1. Emoji Grid Container (where emojis are displayed)
    emojiGridContainer = LinearLayout(this).apply {
        orientation = LinearLayout.VERTICAL
        layoutParams = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.MATCH_PARENT,
            0, // Height is 0, weight 1f means it takes available vertical space
            1f  // Weight to make it expand and fill available space
        )
        // Optional: set padding or background for the grid area
        // setPadding(dpToPx(2), dpToPx(2), dpToPx(2), dpToPx(2))
    }
    emojiMainLayout.addView(emojiGridContainer)

    // 2. Emoji Category Indicator Container (dots)
    emojiCategoryIndicatorContainer = LinearLayout(this).apply {
        orientation = LinearLayout.HORIZONTAL
        layoutParams = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.MATCH_PARENT,
            LinearLayout.LayoutParams.WRAP_CONTENT // Height based on dot size + margins
        )
        gravity = Gravity.CENTER
        setPadding(0, dpToPx(2), 0, dpToPx(6)) // Padding around dots area
    }
    emojiMainLayout.addView(emojiCategoryIndicatorContainer)
    
    // 3. Emoji Category Tabs Container (buttons for direct category selection)
    emojiCategoryTabsContainer = LinearLayout(this).apply {
        orientation = LinearLayout.HORIZONTAL
        layoutParams = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.MATCH_PARENT,
            dpToPx(45) // Fixed height for category tabs row
        )
        gravity = Gravity.CENTER_VERTICAL // Center tabs vertically
        // Optional: set background for tab row
        // setBackgroundColor(specialKeyBackgroundColor) 
    }
    emojiMainLayout.addView(emojiCategoryTabsContainer)

    // 4. Bottom Control Row (ABC, Space, Backspace)
    val emojiBottomControlRow = LinearLayout(this).apply {
        orientation = LinearLayout.HORIZONTAL
        layoutParams = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.MATCH_PARENT,
            dpToPx(55) // Standard key height for this row
        )
        gravity = Gravity.CENTER_VERTICAL
        // Optional: set background for control row
        // setBackgroundColor(keyboardBackgroundColor)
    }

    // Add ABC key to switch back to letter keyboard
    addSpecialKey(emojiBottomControlRow, "ABC", null, 1.5f, true) {
        Log.d(TAG, "Emoji Panel: ABC key pressed. Directly switching to letters keyboard")
        if (isHapticFeedbackEnabled) performHapticFeedback()
        
        try {
            // Reset state variables
            isEmojiKeyboardShown = false
            isSymbolsShown = false
            
            // Save reference to the current input view
            val currentInputView = inputView
            
            // Create a completely new input view to ensure proper initialization
            val newInputView = onCreateInputView()
            
            // Set the new input view as the active input view
            setInputView(newInputView)
            
            Log.d(TAG, "Emoji Panel: ABC key - Successfully created new input view and set it as active")
        } catch (e: Exception) {
            Log.e(TAG, "Error switching from emoji keyboard: ${e.message}")
            e.printStackTrace()
            
            // Fallback approach if the above fails
            isEmojiKeyboardShown = false
            isSymbolsShown = false
            keyboardContainer.removeAllViews()
            setupKeyboard()
        }
    }

    // Add Space bar for emoji panel
    // Double-space for period is handled by handleText
    addKey(emojiBottomControlRow, "space", weight = 5f, isSpacebar = true) {
        handleText(" ", true) // enableHaptic = true for tap, double-space logic in handleText
    }

    // Add Backspace key for emoji panel with turbo delete
    val emojiBackspaceKey = addSpecialKey(emojiBottomControlRow, "", R.drawable.ic_backspace, 1.5f) {
        // Fallback onClick, primarily handled by OnTouchListener
    }
    emojiBackspaceKey.setOnTouchListener { v, event ->
        val ic = currentInputConnection ?: return@setOnTouchListener false
        when (event.action) {
            MotionEvent.ACTION_DOWN -> {
                v.alpha = 0.7f // Visual feedback
                // Start word delete timer
                wordDeleteRunnable = Runnable {
                    isWordDeleteActive = true
                    if (isHapticFeedbackEnabled) v.performHapticFeedback(HapticFeedbackConstants.LONG_PRESS)
                    handleBackspace(ic, true) // isWordDelete's haptic is in handleBackspace
                }
                deleteHandler.postDelayed(wordDeleteRunnable!!, wordDeleteDelay)
                
                // Initial delete (haptic feedback is in handleBackspace)
                handleBackspace(ic, false)
                
                // Start turbo delete sequence
                isDeleting = true
                deleteCount = 0
                deleteRunnable = object : Runnable {
                    override fun run() {
                        if (isDeleting) {
                            handleBackspace(ic, isWordDeleteActive) // Haptic is in handleBackspace
                            deleteCount++
                            val delay = if (deleteCount >= maxDeletesBeforeTurbo) turboDeleteDelay else repeatDeleteDelay
                            deleteHandler.postDelayed(this, delay)
                        }
                    }
                }
                deleteHandler.postDelayed(deleteRunnable, initialDeleteDelay)
                true
            }
            MotionEvent.ACTION_UP, MotionEvent.ACTION_CANCEL -> {
                isDeleting = false
                isWordDeleteActive = false
                wordDeleteRunnable?.let { deleteHandler.removeCallbacks(it) }
                deleteHandler.removeCallbacks(deleteRunnable)
                v.alpha = 1.0f // Reset visual feedback
                true
            }
            else -> false
        }
    }
    emojiMainLayout.addView(emojiBottomControlRow)

    // Add the structured emojiMainLayout to the emojiKeyboardContainer
    emojiKeyboardContainer.addView(emojiMainLayout)
    
    // Add the emojiKeyboardContainer to the main keyboardContainer (from InputMethodService)
    keyboardContainer.addView(emojiKeyboardContainer)

    // Initial population and setup for the emoji categories
    currentEmojiCategoryIndex = 0 // Default to the first category
    populateEmojiGrid()       // Fill the grid with emojis from the current category
    createEmojiCategoryTabs() // Create the category selection tabs
    setupEmojiSwipeDetection()// Enable swipe gestures on the emoji grid for category navigation
    
    Log.d(TAG, "New emoji keyboard with categories setup complete.")
    Log.d(TAG, "setupEmojiKeyboard finished. Final state: isEmojiKeyboardShown=$isEmojiKeyboardShown, isSymbolsShown=$isSymbolsShown")
}
    
    private fun addKey(
        parent: ViewGroup,
        text: String,
        width: Int = 0,
        weight: Float = 1f,
        isSpecial: Boolean = false,
        isSpacebar: Boolean = false,
        onClick: () -> Unit
    ): Button {
        val keyView = LayoutInflater.from(this).inflate(
            R.layout.ios_key_letter, 
            parent,
            false
        ) as Button

        keyView.text = if (text == "space") " " else text

        keyView.setBackgroundColor(keyBackgroundColor)
        keyView.setTextColor(keyTextColor)

        val backgroundDrawable = ContextCompat.getDrawable(this, R.drawable.ios_key_background)?.mutate()
        if (backgroundDrawable != null) {
            DrawableCompat.setTint(backgroundDrawable, keyBackgroundColor)
            keyView.background = backgroundDrawable
        }

        val params = if (width == 0) {
            LinearLayout.LayoutParams(
                0, 
                resources.getDimensionPixelSize(R.dimen.ios_key_height),
                weight
            )
        } else {
            LinearLayout.LayoutParams(
                width, 
                resources.getDimensionPixelSize(R.dimen.ios_key_height),
                weight 
            )
        }.apply {
            val margin = resources.getDimensionPixelSize(R.dimen.ios_key_margin) / 2
            setMargins(margin, margin, margin, margin)
        }
        keyView.layoutParams = params

        keyView.setOnTouchListener { v, event ->
            when (event.action) {
                MotionEvent.ACTION_DOWN -> {
                    v.alpha = 0.7f
                    // Show popup immediately for all non-whitespace keys
                    if (text.isNotBlank() && text != "\n") {
                        showKeyPopup(v, text)
                    }
                    // Post the click to ensure popup shows first
                    v.post { onClick() }
                    true
                }
                MotionEvent.ACTION_UP, MotionEvent.ACTION_CANCEL -> {
                    v.alpha = 1.0f
                    // Dismiss popup when finger is lifted
                    dismissKeyPopup()
                    true
                }
                MotionEvent.ACTION_MOVE -> {
                    // Always update popup position while moving
                    if (text.isNotBlank() && text != "\n") {
                        if (currentPopupKey == v) {
                            updatePopupPosition(v)
                        } else {
                            // If we moved to a different key, dismiss the popup
                            dismissKeyPopup()
                        }
                    }
                    true
                }
                else -> false
            }
        }

        parent.addView(keyView)
        return keyView
    }
    
    private fun showKeyPopup(anchor: View, text: String) {
        try {
            // Skip if already showing popup for this key
            if (currentPopupKey == anchor) {
                updatePopupPosition(anchor)
                return
            }
            
            // Dismiss any existing popup
            dismissKeyPopup()

            val inflater = getSystemService(Context.LAYOUT_INFLATER_SERVICE) as LayoutInflater
            val popupView = inflater.inflate(R.layout.key_popup, null)
            val popupText = popupView.findViewById<TextView>(R.id.popup_text)
            // Show the letter in the correct case based on keyboard state
            popupText.text = if (isCapsOn || isCapsLock) text.uppercase() else text.lowercase()
            
            // Get the key's background color
            val background = anchor.background
            var bgColor = Color.LTGRAY // Default color
            
            if (background is android.graphics.drawable.ColorDrawable) {
                bgColor = background.color
            } else if (background is android.graphics.drawable.GradientDrawable) {
                val constantState = background.constantState
                constantState?.let {
                    val drawable = it.newDrawable().mutate() as android.graphics.drawable.GradientDrawable
                    drawable.setColorFilter(bgColor, android.graphics.PorterDuff.Mode.SRC_ATOP)
                }
            }
            
            // Set the popup background (the circle is handled by the background drawable)
            // Set the popup background based on theme
            val popupBackgroundResId = if (isDarkMode) R.drawable.key_popup_background_dark else R.drawable.key_popup_background
            popupView.background = ContextCompat.getDrawable(this@RewordiumAIKeyboardService, popupBackgroundResId)
            
            // Set text color based on theme
            val textColor = if (isDarkMode) Color.WHITE else Color.BLACK
            popupText.setTextColor(textColor)
            
            // Create the popup window
            // Create a perfectly circular popup
            val popupSize = dpToPx(54)
            keyPopup = PopupWindow(
                popupView,
                popupSize,
                popupSize,
                false
            ).apply {
                // Set background to transparent to show the shadow
                setBackgroundDrawable(android.graphics.drawable.ColorDrawable(Color.TRANSPARENT))
                
                // Disable all animations for instant appearance
                animationStyle = 0
                
                // Set elevation for shadow (iOS uses a more subtle shadow)
                elevation = 4f
                
                // Don't dismiss when touched outside
                isOutsideTouchable = false
                isFocusable = false
                isTouchable = false
                
                // Set input method mode to not need adjustment (reduces delay)
                inputMethodMode = PopupWindow.INPUT_METHOD_NOT_NEEDED
            }
            
            // Show the popup
            updatePopupPosition(anchor)
            currentPopupKey = anchor
        } catch (e: Exception) {
            Log.e("KeyPopup", "Error showing key popup", e)
        }
    }
    
    private fun updatePopupPosition(anchor: View) {
        keyPopup?.let { popup ->
            try {
                // Get the anchor view's location on screen
                val anchorLocation = IntArray(2)
                anchor.getLocationInWindow(anchorLocation)
                
                // Calculate popup position (centered above the key with offset for the triangle)
                val x = anchorLocation[0] + (anchor.width - popup.width) / 2
                // Position the popup above the key with a small gap
                val y = anchorLocation[1] - popup.height - dpToPx(4)
                
                // Get screen dimensions
                val displayMetrics = resources.displayMetrics
                val screenWidth = displayMetrics.widthPixels
                
                // Adjust x position to keep popup on screen with some padding
                val padding = dpToPx(8)
                var adjustedX = x
                
                if (adjustedX < padding) {
                    adjustedX = padding
                } else if (adjustedX + popup.width > screenWidth - padding) {
                    adjustedX = screenWidth - popup.width - padding
                }
                
                // Calculate y position with padding from top
                val adjustedY = y.coerceAtLeast(padding)
                
                // Update popup position
                if (!popup.isShowing) {
                    popup.showAtLocation(
                        anchor,
                        Gravity.TOP or Gravity.START,
                        adjustedX,
                        adjustedY
                    )
                } else {
                    popup.update(adjustedX, adjustedY, -1, -1)
                }
            } catch (e: Exception) {
                Log.e("KeyPopup", "Error updating popup position", e)
            }
        }
    }
    
    private fun dismissKeyPopup() {
        try {
            keyPopup?.let { popup ->
                if (popup.isShowing) {
                    popup.dismiss()
                }
            }
        } catch (e: Exception) {
            Log.e("KeyPopup", "Error dismissing popup", e)
        } finally {
            keyPopup = null
            currentPopupKey = null
        }
    }
    
    private fun dpToPx(dp: Int): Int {
        return (dp * resources.displayMetrics.density).toInt()
    }

    private fun addSpecialKey(
        parent: ViewGroup,
        text: String,
        iconResId: Int? = null,
        weight: Float = 1f,
        isTextKey: Boolean = false,
        onClick: () -> Unit
    ): View {
        val view = if (isTextKey) {
            // Text-based special key
            val keyView = LayoutInflater.from(this).inflate(
                R.layout.ios_key_special,
                parent,
                false
            ) as Button
            
            keyView.text = text
            // Adjust text color for dark mode for keys like '123', 'ABC', '#+=', 'space'
            if (isDarkMode) {
                keyView.setTextColor(Color.WHITE)
            } else {
                keyView.setTextColor(keyTextColor) // Use the standard key text color in light mode
            }
            keyView
        } else {
            // Icon-based special key
            val keyView = LayoutInflater.from(this).inflate(
                R.layout.ios_key_icon,
                parent,
                false
            ) as ImageButton
            
            if (iconResId != null) {
                keyView.setImageResource(iconResId)
                
                // Apply theme color to icon
                val drawable = keyView.drawable.mutate()
                drawable.colorFilter = PorterDuffColorFilter(
                    Color.parseColor(themeColor),
                    PorterDuff.Mode.SRC_IN
                )
            }
            keyView
        }
        
        // Apply special key background with rounded corners
        val backgroundDrawable = GradientDrawable().apply {
            cornerRadius = TypedValue.applyDimension(
                TypedValue.COMPLEX_UNIT_DIP,
                6f,
                resources.displayMetrics
            )
            // Use the special key background color
            setColor(specialKeyBackgroundColor)
        }
        view.background = backgroundDrawable
        
        // For icon-based keys (like backspace), ensure proper padding
        if (view is ImageButton) {
            view.setPadding(0, 10, 0, 0)
        }
        
        val params = LinearLayout.LayoutParams(
            0, 
            resources.getDimensionPixelSize(R.dimen.ios_key_height),
            weight
        ).apply {
            val margin = resources.getDimensionPixelSize(R.dimen.ios_key_margin) / 2
            setMargins(margin, margin, margin, margin)
        }
        
        view.layoutParams = params
        // Special handling for return key - to ensure it works with context-specific actions
        if (text.equals("return", ignoreCase = true)) {
            // Track if we've already triggered the action to prevent double execution
            var actionTriggered = false
            
            // For return key, directly set the OnClickListener with context-aware logic
            view.setOnClickListener {
                // This should run when user lifts finger
                if (!actionTriggered) {
                    actionTriggered = true
                    onClick()
                    // Reset after a delay
                    Handler(Looper.getMainLooper()).postDelayed({ actionTriggered = false }, 100)
                }
            }
            
            // For visual feedback only, no haptic feedback here
            view.setOnTouchListener { v, event ->
                when (event.action) {
                    MotionEvent.ACTION_DOWN -> {
                        // Visual feedback only
                        v.alpha = 0.7f
                        false // Don't consume the event
                    }
                    MotionEvent.ACTION_UP -> {
                        // Reset visual state and perform click (which triggers our onClick)
                        v.alpha = 1.0f
                        v.performClick() // Explicitly trigger the click
                        true // Consume this event after triggering the click
                    }
                    MotionEvent.ACTION_CANCEL -> {
                        // Just reset visual state
                        v.alpha = 1.0f
                        false
                    }
                    else -> false
                }
            }
        } else {
            // For all other special keys, use the original behavior: immediate response on ACTION_DOWN
            view.setOnTouchListener { v, event ->
                when (event.action) {
                    MotionEvent.ACTION_DOWN -> {
                        // Visual feedback
                        v.alpha = 0.7f
                        // Perform click action immediately on touch down
                        onClick()
                        true // Consume the event
                    }
                    MotionEvent.ACTION_UP, MotionEvent.ACTION_CANCEL -> {
                        // Reset visual state
                        v.alpha = 1.0f
                        true // Consume the event
                    }
                    else -> false
                }
            }
            
            // Keep click listener as fallback for accessibility
            view.setOnClickListener {
                // Action already handled in touch listener
            }
        }
        
        parent.addView(view)
        return view
    }
    
    private fun toggleCapsLock() {
        if (isHapticFeedbackEnabled) performHapticFeedback()

        val currentTime = System.currentTimeMillis()
        
        if (isCapsLock) {
            // If already in caps lock, a single tap will turn it off
            isCapsLock = false
            isCapsOn = false
        } else {
            // Check if this is a fast double-tap on shift (within 200ms)
            if (isCapsOn && currentTime - lastShiftTime < 200) {
                // Fast double-tap detected, activate caps lock
                isCapsLock = true
            } else if (isCapsOn) {
                // Second tap after normal shift (not a fast double-tap)
                // Toggle back to normal state
                isCapsOn = false
            } else {
                // First tap - turn on shift
                isCapsOn = true
            }
        }
        
        // Update the shift key last press time
        lastShiftTime = currentTime
        
        // Update the keyboard layout
        setupKeyboard()
    }
    
    private fun handleBackspace(ic: InputConnection, isWordDelete: Boolean = false) {
        // Provide haptic feedback for each deletion
        if (isHapticFeedbackEnabled) {
            performHapticFeedback()
        }

        val selectedText = ic.getSelectedText(0)
        if (selectedText.isNullOrEmpty()) {
            if (isWordDelete) {
                // Delete entire word
                val wordToDelete = ic.getTextBeforeCursor(100, 0)?.toString()
                if (!wordToDelete.isNullOrEmpty()) {
                    val lastSpace = wordToDelete.lastIndexOf(' ')
                    val charsToDelete = if (lastSpace == -1) {
                        wordToDelete.length
                    } else {
                        wordToDelete.length - lastSpace - 1
                    }
                    
                    if (charsToDelete > 0) {
                        ic.deleteSurroundingText(charsToDelete, 0)
                        if (isHapticFeedbackEnabled) {
                            performHapticFeedback()
                        }
                        return
                    }
                }
            }
            
            // Regular character deletion
            // Use KEYCODE_DEL for potentially better handling of complex characters like emojis
        val textBeforeCursor = ic.getTextBeforeCursor(1, 0) // Check if there's anything to delete
        if (!textBeforeCursor.isNullOrEmpty()) {
            val eventTime = SystemClock.uptimeMillis()
            ic.sendKeyEvent(KeyEvent(eventTime, eventTime, KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_DEL, 0))
            ic.sendKeyEvent(KeyEvent(eventTime, eventTime + 10, KeyEvent.ACTION_UP, KeyEvent.KEYCODE_DEL, 0)) // Small delay for UP event
        }
        } else {
            // Delete the selection
            ic.commitText("", 1)
        }
        
        // Turn off caps if needed
        if (isAutoCapitalizeEnabled) {
            // Check if we're at the beginning of a sentence
            val beforeCursor = ic.getTextBeforeCursor(2, 0)
            if (beforeCursor != null && (beforeCursor.isEmpty() || 
                (beforeCursor.length >= 2 && beforeCursor[beforeCursor.length - 2] != '.' && 
                 beforeCursor[beforeCursor.length - 2] != '?' && 
                 beforeCursor[beforeCursor.length - 2] != '!'))) {
                isCapsOn = false
                setupKeyboard()
            }
        }
    }
    
    // AI button implementation moved to the main handleAIButton method below
    
    /**
     * Public methods for settings updates
     */
    
    /**
     * Updates the keyboard theme color
     */
    fun updateThemeColor(colorHex: String) {
        themeColor = colorHex
        preferences.edit().putString(MainActivity.KEY_THEME_COLOR, colorHex).apply()
        
        // Force recreate the keyboard
        Handler(Looper.getMainLooper()).post {
            try {
                // Force recreate input view
                inputView = null
                val newInputView = onCreateInputView()
                setInputView(newInputView)
                
                // Update UI
                updateColors()
                setupKeyboard()
                
                // Force redraw
                newInputView?.invalidate()
                
            } catch (e: Exception) {
                Log.e(TAG, "Error updating theme color: ${e.message}")
                e.printStackTrace()
            }
        }
    }
    
    /**
     * Toggles dark mode
     */
    fun setDarkMode(enabled: Boolean) {
        if (isDarkMode != enabled) {
            isDarkMode = enabled
            preferences.edit().putBoolean(MainActivity.KEY_DARK_MODE, enabled).apply()
            
            // Update colors and keyboard first
            updateColors()
            setupKeyboard()
            
            // Force refresh the UI and suggestion views
            Handler(Looper.getMainLooper()).post {
                try {
                    // Re-initialize suggestion bar with new theme
                    if (::suggestionContainer.isInitialized) {
                        // Save current suggestions
                        val currentSuggestions = this.currentSuggestions.toList()
                        // Re-initialize with new theme
                        initSuggestionBar()
                        // Restore suggestions with new theme
                        updateSuggestions(currentSuggestions)
                    }
                    
                    // Force redraw
                    inputView?.invalidate()
                    inputView?.requestLayout()
                } catch (e: Exception) {
                    Log.e(TAG, "Error updating dark mode: ${e.message}")
                    e.printStackTrace()
                }
            }
        }
    }
    
    /**
     * Toggles haptic feedback
     */
    fun setHapticFeedback(enabled: Boolean) {
        isHapticFeedbackEnabled = enabled
        preferences.edit().putBoolean(KEY_HAPTIC_FEEDBACK, enabled).apply()
    }
    
    /**
     * Toggles auto-capitalization
     */
    fun setAutoCapitalize(enabled: Boolean) {
        isAutoCapitalizeEnabled = enabled
        preferences.edit().putBoolean(KEY_AUTO_CAPITALIZE, enabled).apply()
    }
    
    /**
     * Toggles double-space for period
     */
    fun setDoubleSpacePeriod(enabled: Boolean) {
        isDoubleSpacePeriodEnabled = enabled
        preferences.edit().putBoolean(KEY_DOUBLE_SPACE_PERIOD, enabled).apply()
    }
    
    /**
     * Refreshes the keyboard UI with the latest settings
     */
    fun refreshKeyboard() {
        try {
            // Settings are loaded in onCreate and colors updated by updateColors()
            
            // Post to main thread for UI updates
            Handler(Looper.getMainLooper()).post {
                try {
                    // Force restart input
                    restartInput()
                    
                    // Update UI
                    updateColors()
                    setupKeyboard()
                    
                    // Force a redraw
                    inputView?.invalidate()
                    
                } catch (e: Exception) {
                    Log.e(TAG, "Error in refreshKeyboard UI update: ${e.message}")
                    e.printStackTrace()
                }
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error in refreshKeyboard: ${e.message}")
            e.printStackTrace()
        }
    }
    
    /**
     * Forces a restart of the input method
     */
    private fun restartInput() {
        try {
            Log.d(TAG, "Restarting input method")
            // Save the current input type
            val inputType = currentInputEditorInfo?.inputType ?: 0
            
            // Reset state variables to ensure clean restart
            isParaphrasingMode = false
            currentOriginalTextForParaphrase = null
            isEmojiKeyboardShown = false
            isSymbolsShown = false
            
            // Force recreate the input view
            inputView = null
            val newInputView = onCreateInputView()
            setInputView(newInputView)
            
            // Force input method restart
            onStartInput(currentInputEditorInfo, false)
            onStartInputView(currentInputEditorInfo, false)
            
            // Request focus
            newInputView?.requestFocus()
            
            Log.d(TAG, "Input method successfully restarted")
        } catch (e: Exception) {
            Log.e(TAG, "Error in restartInput: ${e.message}")
            e.printStackTrace()
        }
    }
    
    override fun onStartInputView(info: EditorInfo?, restarting: Boolean) {
        try {
            Log.d(TAG, "onStartInputView called, restarting=$restarting, needsCompleteRefresh=$needsCompleteRefresh")
            
            // Always call super first
            super.onStartInputView(info, restarting)
            
            val inputType = info?.inputType ?: 0
            isTextOrSearchField = (inputType and InputType.TYPE_MASK_CLASS) == InputType.TYPE_CLASS_TEXT ||
                             (inputType and InputType.TYPE_MASK_VARIATION) == InputType.TYPE_TEXT_VARIATION_WEB_EDIT_TEXT ||
                             (info?.imeOptions ?: 0 and EditorInfo.IME_FLAG_NO_ENTER_ACTION) == 0
            currentInputEditorInfo = info

            currentInputTypeSupportsMultiLine = (inputType and InputType.TYPE_TEXT_FLAG_IME_MULTI_LINE) != 0

            currentEditorAction = info?.imeOptions?.and(EditorInfo.IME_MASK_ACTION) ?: EditorInfo.IME_ACTION_NONE
            if (currentEditorAction == EditorInfo.IME_ACTION_UNSPECIFIED) { 
                currentEditorAction = EditorInfo.IME_ACTION_NONE
            }
            
            // Reset special modes
            isParaphrasingMode = false
            currentOriginalTextForParaphrase = null
            
            // Reset caps lock based on input type
            if (isAutoCapitalizeEnabled) {
                val isCapEnabled = (inputType and EditorInfo.TYPE_TEXT_FLAG_CAP_SENTENCES) != 0 ||
                               (inputType and EditorInfo.TYPE_TEXT_FLAG_CAP_WORDS) != 0 ||
                               (inputType and EditorInfo.TYPE_TEXT_FLAG_CAP_CHARACTERS) != 0
                
                isCapsOn = isCapEnabled
            }
            
            // Handle keyboard initialization
            if (needsCompleteRefresh || restarting) {
                Log.d(TAG, "Creating completely new input view")
                
                // Force keyboard container cleanup
                if (::keyboardContainer.isInitialized) {
                    keyboardContainer.removeAllViews()
                }
                
                // Create and set a completely new input view
                inputView = null
                val newInputView = onCreateInputView()
                setInputView(newInputView)
                
                // Reset the flag
                needsCompleteRefresh = false
                
                Log.d(TAG, "New input view created and set successfully")
            } else {
                // Just setup the keyboard for a new input
                setupKeyboard()
            }
            
            // Initialize suggestions if not already done
            if (!::suggestionContainer.isInitialized) {
                initSuggestionBar()
            }
            
            // Clear suggestions when input view is started
            updateSuggestions(emptyList())
            lastInputText = ""
        } catch (e: Exception) {
            Log.e(TAG, "Error in onStartInputView: ${e.message}")
            e.printStackTrace()
            
            // Fallback - completely reset keyboard state and create a new view
            try {
                isParaphrasingMode = false
                isEmojiKeyboardShown = false
                isSymbolsShown = false
                isCapsOn = false
                isCapsLock = false
                needsCompleteRefresh = false
                
                inputView = null
                val newInputView = onCreateInputView()
                setInputView(newInputView)
            } catch (e2: Exception) {
                Log.e(TAG, "Critical error in fallback: ${e2.message}")
                e2.printStackTrace()
            }
        }
    }
    
    override fun onFinishInputView(finishingInput: Boolean) {
        Log.d(TAG, "onFinishInputView called, finishingInput=$finishingInput")
        try {
            // This method is called when the input view is being hidden
            // Reset all keyboard state variables
            isParaphrasingMode = false
            currentOriginalTextForParaphrase = null
            isEmojiKeyboardShown = false
            isSymbolsShown = false
            isCapsOn = false
            isCapsLock = false
            currentEmojiCategoryIndex = 0
            
            // Mark that we need a complete refresh next time
            needsCompleteRefresh = true
            
            // Clear any pending operations
            Handler(Looper.getMainLooper()).removeCallbacksAndMessages(null)
            
            // Important to call super after our cleanup
            super.onFinishInputView(finishingInput)
        } catch (e: Exception) {
            Log.e(TAG, "Error in onFinishInputView: ${e.message}")
            e.printStackTrace()
            super.onFinishInputView(finishingInput)
        }
    }
    
    override fun onFinishInput() {
        Log.d(TAG, "onFinishInput called, cleaning up state")
        try {
            // Reset paraphrasing mode if active
            if (isParaphrasingMode) {
                isParaphrasingMode = false
                currentOriginalTextForParaphrase = null
            }
            
            // Clean up any active input state
            currentInputConnection?.finishComposingText()
            
            // Reset keyboard state variables to default
            isCapsOn = false
            isCapsLock = false
            isEmojiKeyboardShown = false
            isSymbolsShown = false
            currentEmojiCategoryIndex = 0
            
            // Call super after our cleanup
            super.onFinishInput()
        } catch (e: Exception) {
            Log.e(TAG, "Error in onFinishInput: ${e.message}")
            e.printStackTrace()
            super.onFinishInput()
        }
    }
    
    override fun onKeyDown(keyCode: Int, event: KeyEvent?): Boolean {
        val currentInputConnection = currentInputConnection ?: return false
        
        when (keyCode) {
            KeyEvent.KEYCODE_DEL -> {
                handleBackspace(currentInputConnection)
                return true
            }
            KeyEvent.KEYCODE_ENTER -> {
                currentInputConnection.performEditorAction(EditorInfo.IME_ACTION_DONE)
                return true
            }
            KeyEvent.KEYCODE_SPACE -> {
                handleText(" ", true)
                return true
            }
        }
        
        return super.onKeyDown(keyCode, event)
    }
    
    override fun onDestroy() {
        super.onDestroy()
        Log.d(TAG, "RewordiumAIKeyboardService destroyed")
        try {
            unregisterReceiver(themeUpdateReceiver)
            Log.d(TAG, "Theme update receiver unregistered.")
        } catch (e: IllegalArgumentException) {
            Log.w(TAG, "Theme update receiver was not registered or already unregistered.", e)
        }
        try {
            unregisterReceiver(personaUpdateReceiver)
            Log.d(TAG, "Persona update receiver unregistered.")
        } catch (e: IllegalArgumentException) {
            Log.w(TAG, "Persona update receiver was not registered or already unregistered.", e)
        }
        
        // Nullify other resources, handlers, etc.
        keyPopup?.dismiss() // Dismiss any active popup
        keyPopup = null
        inputView = null
        // Be careful with coroutine scopes, cancel them if they are tied to the service lifecycle
        // e.g., if you have a service-specific CoroutineScope: serviceScope.cancel()
        deleteHandler.removeCallbacksAndMessages(null) // Clean up handler callbacks
    }
    
    private fun showToast(message: String) {
        Handler(Looper.getMainLooper()).post {
            Toast.makeText(this, message, Toast.LENGTH_SHORT).show()
        }
    }
    
    /**
     * Initialize the paraphrase view - this happens in onCreateInputView
     */
    private fun initParaphraseView() {
        // No initialization needed with the new direct approach
    }
    
    /**
     * Show the paraphrase view by replacing letter keys with paraphrase options
     * Includes a persona selector for different paraphrase styles
     */
    private fun showParaphraseView(originalText: String) {
        this.currentOriginalTextForParaphrase = originalText
        // Save original text
        this.originalText = originalText
        
        // Clear the rows
        rowQwerty.removeAllViews()
        rowAsdf.removeAllViews()
        rowZxcv.removeAllViews()
        
        // Hide keyboard elements for clean UI
        numberRow.visibility = View.GONE
        suggestionContainer.visibility = View.GONE
        bottomRow.visibility = View.GONE
        
        // Set clean iOS-style background
        keyboardContainer.setBackgroundColor(if (isDarkMode) Color.parseColor("#1C1C1E") else Color.parseColor("#F2F2F7"))
        
        // ===== Create minimal iOS-style header container =====
        val headerContainer = LinearLayout(this)
        headerContainer.orientation = LinearLayout.VERTICAL
        headerContainer.layoutParams = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.MATCH_PARENT,
            LinearLayout.LayoutParams.WRAP_CONTENT
        )
        
        // ===== Create minimal iOS-style header bar =====
        val headerBar = LinearLayout(this)
        headerBar.orientation = LinearLayout.HORIZONTAL
        headerBar.gravity = Gravity.CENTER_VERTICAL
        headerBar.setBackgroundColor(Color.TRANSPARENT) // Clean transparent background
        headerBar.elevation = 0f // Flat design
        val headerParams = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.MATCH_PARENT,
            dpToPx(44) // Standard iOS header height
        )
        
        // Minimal back button (iOS style)
        val backButton = TextView(this)
        backButton.text = "âŸµ"
        backButton.setTextColor(Color.parseColor("#007AFF")) // iOS blue
        backButton.textSize = 18f
        backButton.typeface = Typeface.create("sans-serif-medium", Typeface.NORMAL)
        backButton.gravity = Gravity.CENTER_VERTICAL
        backButton.setPadding(dpToPx(16), 0, dpToPx(8), 0)
        backButton.setOnClickListener {
            hideParaphraseView()
        }
        
        // Clean, minimal title
        val titleView = TextView(this)
        titleView.text = "Paraphrase"
        titleView.setTextColor(if (isDarkMode) Color.WHITE else Color.BLACK)
        titleView.textSize = 17f
        titleView.typeface = Typeface.create("sans-serif-medium", Typeface.NORMAL)
        titleView.gravity = Gravity.CENTER
        titleView.layoutParams = LinearLayout.LayoutParams(
            0, LinearLayout.LayoutParams.WRAP_CONTENT, 1f
        )
        
        // Empty space on right side for visual balance
        val rightSpace = View(this)
        rightSpace.layoutParams = LinearLayout.LayoutParams(dpToPx(44), LinearLayout.LayoutParams.MATCH_PARENT)
        
        // Assemble header
        headerBar.addView(backButton)
        headerBar.addView(titleView)
        headerBar.addView(rightSpace)
        headerContainer.addView(headerBar)
        
        // Add subtle divider line
        val divider = View(this)
        divider.layoutParams = LinearLayout.LayoutParams(LinearLayout.LayoutParams.MATCH_PARENT, 1)
        divider.setBackgroundColor(if (isDarkMode) Color.parseColor("#333333") else Color.parseColor("#D1D1D6"))
        headerContainer.addView(divider)
        
        Log.d(TAG, "[showParaphraseView] Building UI with availablePersonas: ${availablePersonas.joinToString(",")}")
        // ===== Create iOS-style persona selector =====
        val personaSelector = LinearLayout(this)
        personaSelector.orientation = LinearLayout.HORIZONTAL
        personaSelector.gravity = Gravity.CENTER
        personaSelector.setPadding(dpToPx(12), dpToPx(12), dpToPx(12), dpToPx(12))
        personaSelector.layoutParams = LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.MATCH_PARENT,
            LinearLayout.LayoutParams.WRAP_CONTENT
        )
        
        // Map of iOS-style accent colors for personas
        val accentColors = mapOf(
            "Neutral" to Color.parseColor("#007AFF"), // iOS blue
            "Happy" to Color.parseColor("#34C759"),  // iOS green
            "Sad" to Color.parseColor("#FF9500"),    // iOS orange
            "Humor" to Color.parseColor("#FF2D55"),  // iOS pink
            "Formal" to Color.parseColor("#5856D6"), // iOS purple
            "Casual" to Color.parseColor("#FF3B30")  // iOS red
        )
        
        // Create segment control for personas
        for (persona in availablePersonas) {
            val button = TextView(this)
            button.text = persona
            button.textSize = 14f
            button.gravity = Gravity.CENTER
            button.setPadding(dpToPx(8), dpToPx(8), dpToPx(8), dpToPx(8))
            button.typeface = Typeface.create("sans-serif", Typeface.NORMAL)
            
            // Style based on selection state
            val isSelected = persona == currentPersona
            val accentColor = accentColors[persona] ?: accentColors["Neutral"]!!
            
            // Create iOS-style pill-shaped button
            val drawable = GradientDrawable()
            drawable.shape = GradientDrawable.RECTANGLE
            drawable.cornerRadius = dpToPx(8).toFloat()
            
            if (isSelected) {
                // Selected state
                drawable.setColor(accentColor)
                button.setTextColor(Color.WHITE)
                button.typeface = Typeface.create("sans-serif-medium", Typeface.NORMAL)
            } else {
                // Unselected state
                drawable.setColor(Color.TRANSPARENT)
                drawable.setStroke(1, accentColor)
                button.setTextColor(accentColor)
            }
            
            button.background = drawable
            
            // Set click listener to change persona
            button.setOnClickListener {
                if (currentPersona != persona) {
                    currentPersona = persona
                    generateParaphraseWithPersona(originalText, persona)
                    showParaphraseView(originalText) // Refresh UI with new persona
                }
            }
            
            // Add to selector with even spacing
            val buttonParams = LinearLayout.LayoutParams(
                0, LinearLayout.LayoutParams.WRAP_CONTENT, 1f
            )
            buttonParams.setMargins(dpToPx(2), 0, dpToPx(2), 0)
            personaSelector.addView(button, buttonParams)
        }
        
        // Add persona selector to header container
        headerContainer.addView(personaSelector)
        
        // Add header container to top row
        rowQwerty.addView(headerContainer)
        
        // ===== Create original text container =====
        val originalTextContainer = LinearLayout(this)
        originalTextContainer.orientation = LinearLayout.VERTICAL
        originalTextContainer.gravity = Gravity.CENTER
        originalTextContainer.setPadding(dpToPx(16), dpToPx(8), dpToPx(16), dpToPx(8))
        
        // Original text view - iOS style with subtle background
        val originalTextView = TextView(this)
        originalTextView.text = originalText
        originalTextView.setTextColor(if (isDarkMode) Color.parseColor("#8E8E93") else Color.parseColor("#3A3A3C"))
        originalTextView.textSize = 14f
        originalTextView.typeface = Typeface.create("sans-serif", Typeface.ITALIC)
        originalTextView.gravity = Gravity.CENTER
        originalTextView.setPadding(dpToPx(16), dpToPx(12), dpToPx(16), dpToPx(12))
        
        // Subtle background for original text
        val textBackground = GradientDrawable()
        textBackground.cornerRadius = dpToPx(8).toFloat()
        textBackground.setColor(if (isDarkMode) Color.parseColor("#2C2C2E") else Color.parseColor("#E5E5EA"))
        originalTextView.background = textBackground
        
        originalTextContainer.addView(originalTextView)
        rowAsdf.addView(originalTextContainer)
        
        // ===== Create loading container =====
        val loadingContainer = LinearLayout(this)
        loadingContainer.orientation = LinearLayout.VERTICAL
        loadingContainer.gravity = Gravity.CENTER
        loadingContainer.setPadding(dpToPx(16), dpToPx(16), dpToPx(16), dpToPx(16))
        loadingContainer.tag = "loadingContainer" // Add tag for reference
        
        // iOS-style loading spinner
        val progressBar = ProgressBar(this)
        progressBar.indeterminateTintList = ColorStateList.valueOf(accentColors[currentPersona] ?: accentColors["Neutral"]!!)
        
        // Loading text with persona mention
        val loadingText = TextView(this)
        loadingText.text = "Generating ${currentPersona.lowercase()} paraphrases..."
        loadingText.setTextColor(if (isDarkMode) Color.WHITE else Color.BLACK)
        loadingText.textSize = 15f
        loadingText.typeface = Typeface.create("sans-serif", Typeface.NORMAL)
        loadingText.gravity = Gravity.CENTER
        loadingText.setPadding(0, dpToPx(16), 0, 0)
        
        // Add views to loading container
        loadingContainer.addView(progressBar)
        loadingContainer.addView(loadingText)
        
        // Add to middle row
        rowZxcv.addView(loadingContainer)
        
        // Set paraphrasing mode flag
        isParaphrasingMode = true
    }
    
    /**
     * Hide the paraphrase view and restore normal keyboard
     */
    private fun hideParaphraseView() {
        try {
            Log.d(TAG, "Hiding paraphrase view and restoring keyboard")
            
            // Clear paraphrasing mode
            isParaphrasingMode = false
            currentOriginalTextForParaphrase = null
            
            // Mark for complete refresh when keyboard reopens
            needsCompleteRefresh = true
            
            // Create a completely new input view to ensure proper initialization
            val newInputView = onCreateInputView()
            
            // Set the new input view as the active input view
            setInputView(newInputView)
            
            Log.d(TAG, "Successfully restored keyboard after paraphrasing")
        } catch (e: Exception) {
            Log.e(TAG, "Error restoring keyboard after paraphrasing: ${e.message}")
            e.printStackTrace()
            
            // Fallback approach
            isParaphrasingMode = false
            currentOriginalTextForParaphrase = null
            
            // Reset keyboard state flags to prevent conflicts
            isEmojiKeyboardShown = false
            isSymbolsShown = false
            
            // Show number keys row again
            numberRow.visibility = View.VISIBLE
            
            // Show suggestions again
            suggestionContainer.visibility = View.VISIBLE
            
            // Show bottom row again with 123, globe, spacebar, emoji and return keys
            bottomRow.visibility = View.VISIBLE
            
            // Apply the proper theme colors (will set background color)
            applyThemeColors()
            rowQwerty.removeAllViews()
            rowAsdf.removeAllViews()
            rowZxcv.removeAllViews()
            
            // Rebuild the keyboard layout
            setupKeyboard()
        }
    }
private fun updateParaphraseOptions(paraphrases: List<String>) {
    // 1. Explicitly find and remove the loading container from rowZxcv
    val loadingContainerFromZxcv = rowZxcv.findViewWithTag<LinearLayout>("loadingContainer")
    loadingContainerFromZxcv?.let {
        rowZxcv.removeView(it)
        Log.d(TAG, "[updateParaphraseOptions] Removed loading container from rowZxcv")
    }

    // Make sure we have paraphrases to display
    if (paraphrases.isEmpty()) {
        hideParaphraseView()
        showToast("Failed to generate paraphrases")
        return
    }

    // 2. Clear rowAsdf before adding new content
    rowAsdf.removeAllViews()
    Log.d(TAG, "[updateParaphraseOptions] Cleared rowAsdf for new paraphrase options")

    // Set clean iOS-style background (maintain the existing one)
    keyboardContainer.setBackgroundColor(if (isDarkMode) Color.parseColor("#1C1C1E") else Color.parseColor("#F2F2F7"))

    // Old loadingContainer logic targeting rowAsdf removed as it's now handled correctly.

    // Create a clean, scrollable container for paraphrase options
    val scrollView = ScrollView(this)
    scrollView.layoutParams = LinearLayout.LayoutParams(
        LinearLayout.LayoutParams.MATCH_PARENT,
        LinearLayout.LayoutParams.WRAP_CONTENT
    )
    scrollView.setBackgroundColor(Color.TRANSPARENT) // Clean transparent background
    scrollView.isVerticalScrollBarEnabled = false // Hide scroll bar for cleaner look

    // Container for all paraphrase options with clean styling
    val optionsContainer = LinearLayout(this)
    optionsContainer.orientation = LinearLayout.VERTICAL
    optionsContainer.setPadding(dpToPx(16), dpToPx(8), dpToPx(16), dpToPx(8))
    optionsContainer.layoutParams = LinearLayout.LayoutParams(
        LinearLayout.LayoutParams.MATCH_PARENT,
        LinearLayout.LayoutParams.WRAP_CONTENT
    )

    // Create TextView for each paraphrase (limited to 3 maximum)
    val displayParaphrases = paraphrases.take(3)

    // Map of iOS-style accent colors for personas
    val accentColors = mapOf(
        "Neutral" to if (isDarkMode) "#64D2FF" else "#007AFF", // Blue
        "Happy" to if (isDarkMode) "#30D158" else "#34C759",   // Green
        "Sad" to if (isDarkMode) "#FF9F0A" else "#FF9500",     // Orange
        "Humor" to if (isDarkMode) "#FF375F" else "#FF2D55",   // Pink
        "Formal" to if (isDarkMode) "#5E5CE6" else "#5856D6",  // Purple
        "Casual" to if (isDarkMode) "#FF453A" else "#FF3B30"   // Red
    )

    // Get accent color for current persona
    val personaColor = accentColors[currentPersona] ?: accentColors["Neutral"]!!

    displayParaphrases.forEachIndexed { index, text ->
        // Modern, clean iOS-style card container
        val cardContainer = LinearLayout(this)
        cardContainer.orientation = LinearLayout.HORIZONTAL
        cardContainer.gravity = Gravity.CENTER_VERTICAL

        // Clean, minimal card background
        val cardBackgroundDrawable = GradientDrawable().apply {
            setColor(if (isDarkMode) Color.parseColor("#2C2C2E") else Color.parseColor("#FFFFFF"))
            cornerRadius = dpToPx(12).toFloat()
            setStroke(1, if (isDarkMode) Color.parseColor("#3A3A3C") else Color.parseColor("#E5E5EA"))
        }
        cardContainer.background = cardBackgroundDrawable // Apply initial background

        // Add persona-colored accent indicator on the side (iOS style)
        val accentIndicator = View(this)
        val indicatorParams = LinearLayout.LayoutParams(dpToPx(4), LinearLayout.LayoutParams.MATCH_PARENT)
        accentIndicator.layoutParams = indicatorParams
        accentIndicator.setBackgroundColor(Color.parseColor(personaColor))
        cardContainer.addView(accentIndicator)

        // Clean, minimal paraphrase content
        val optionView = TextView(this)
        optionView.text = text
        optionView.setTextColor(if (isDarkMode) Color.WHITE else Color.BLACK)
        optionView.textSize = 15f
        optionView.typeface = Typeface.create("sans-serif", Typeface.NORMAL)
        optionView.layoutParams = LinearLayout.LayoutParams(
            0, LinearLayout.LayoutParams.WRAP_CONTENT, 1.0f
        )
        optionView.setPadding(dpToPx(16), dpToPx(16), dpToPx(16), dpToPx(16))
        optionView.gravity = Gravity.START or Gravity.CENTER_VERTICAL

        cardContainer.addView(optionView) // Add option text to card

        cardContainer.isClickable = true
        cardContainer.isFocusable = true

        val stateListDrawable = StateListDrawable()
        val pressedDrawable = GradientDrawable().apply {
            setColor(if (isDarkMode) Color.parseColor("#3A3A3C") else Color.parseColor("#F2F2F7"))
            cornerRadius = dpToPx(12).toFloat()
            setStroke(1, if (isDarkMode) Color.parseColor("#3A3A3C") else Color.parseColor("#E5E5EA"))
        }
        stateListDrawable.addState(intArrayOf(android.R.attr.state_pressed), pressedDrawable)
        stateListDrawable.addState(intArrayOf(), cardBackgroundDrawable) // Default state
        cardContainer.background = stateListDrawable

        cardContainer.setOnClickListener {
            applyParaphrase(text)
            hideParaphraseView()
        }
        optionsContainer.addView(cardContainer)

        if (index < displayParaphrases.size - 1) {
            val spacer = View(this)
            spacer.layoutParams = LinearLayout.LayoutParams(
                LinearLayout.LayoutParams.MATCH_PARENT,
                dpToPx(8)
            )
            optionsContainer.addView(spacer)
        }
    }
    scrollView.addView(optionsContainer)

    val scrollContainer = LinearLayout(this)
    scrollContainer.orientation = LinearLayout.VERTICAL
    scrollContainer.layoutParams = LinearLayout.LayoutParams(
        LinearLayout.LayoutParams.MATCH_PARENT,
        LinearLayout.LayoutParams.WRAP_CONTENT 
    )
    scrollContainer.gravity = Gravity.CENTER_HORIZONTAL 
    scrollContainer.setPadding(0, dpToPx(8), 0, dpToPx(8)) 

    scrollContainer.addView(scrollView)
    rowAsdf.addView(scrollContainer)
}

    private fun applyParaphrase(paraphrase: String) {
        val ic = currentInputConnection ?: return
        
        // Delete the current sentence
        val textBeforeCursor = ic.getTextBeforeCursor(1000, 0)?.toString() ?: ""
        if (currentSentenceStart >= 0 && currentSentenceStart < textBeforeCursor.length) {
            val lengthToDelete = textBeforeCursor.length - currentSentenceStart
            ic.deleteSurroundingText(lengthToDelete, 0)
            
            // Insert the paraphrased sentence
            ic.commitText(paraphrase, 1)
        }
    }
    
    // Note: currentPersona and availablePersonas are declared at the top of the class
    
    /**
     * Update the selected keyboard personas from Flutter settings or API calls
     */
    fun updateKeyboardPersonas(personaList: List<String>) {
        Log.d(TAG, "[updateKeyboardPersonas] Input personaList: ${personaList.joinToString(",")}")
        Log.d(TAG, "Received persona list from settings: ${personaList.joinToString(",")}")

        val newAvailablePersonas = mutableListOf<String>()
        newAvailablePersonas.add("Neutral") // Neutral is always the first and default

        // Filter out "Neutral" from the input list, then take up to 3 other unique personas
        val userSelectedPersonas = personaList.filter { it != "Neutral" }.distinct()
        userSelectedPersonas.take(3).forEach {
            if (!newAvailablePersonas.contains(it)) {
                newAvailablePersonas.add(it)
            }
        }

        availablePersonas.clear()
        availablePersonas.addAll(newAvailablePersonas)
        
        Log.d(TAG, "[updateKeyboardPersonas] Final availablePersonas: ${availablePersonas.joinToString(",")}")
        Log.d(TAG, "[updateKeyboardPersonas] Personas updated and saved to SharedPreferences: ${availablePersonas.joinToString(",")}")
        
        // Reset current persona to Neutral if needed
        if (!availablePersonas.contains(currentPersona)) {
            currentPersona = "Neutral"
        }
        
        // Save the updated personas to SharedPreferences for persistence
        val prefs = getSharedPreferences(MainActivity.PREFS_NAME, Context.MODE_PRIVATE)
        prefs.edit()
            .putString("keyboard_personas", availablePersonas.joinToString(","))
            .apply()
        
        Log.d(TAG, "[updateKeyboardPersonas] Personas updated and saved: ${availablePersonas.joinToString(",")}")
    }
    
    /**
     * Handles the AI button click to paraphrase the current sentence
     * Uses Groq API with Llama 3 model to generate paraphrases
     */
    private fun handleAIButton() {
        // Trigger haptic feedback if enabled
        if (isHapticFeedbackEnabled) {
            performHapticFeedback()
        }
        
        val ic = currentInputConnection ?: return
        
        // Get the current sentence
        val textBeforeCursor = ic.getTextBeforeCursor(1000, 0)?.toString() ?: ""
        
        // Find the start of the current sentence
        val sentenceStart = findSentenceStart(textBeforeCursor)
        val currentSentence = textBeforeCursor.substring(sentenceStart)
        
        // Skip if sentence is too short
        if (currentSentence.trim().length < 5) {
            showToast("Please type a longer sentence to paraphrase")
            return
        }
        
        Log.d(TAG, "Paraphrasing sentence: $currentSentence")
        
        // Reset to Neutral persona before showing UI
        currentPersona = "Neutral"
        
        // Show paraphrase view with loading state and persona selection
        showParaphraseView(currentSentence)
        
        // Set paraphrasing mode flag and remember sentence start position
        isParaphrasingMode = true
        currentSentenceStart = sentenceStart
        
        // Generate paraphrase with current persona
        generateParaphraseWithPersona(currentSentence, currentPersona)
    }
    
    /**
     * Generate paraphrases with the selected persona
     */
    private fun generateParaphraseWithPersona(text: String, persona: String) {
        // Use coroutine to make API call in background
        CoroutineScope(Dispatchers.Main).launch {
            try {
                // Get paraphrases from Groq API with persona
                val paraphrases = withContext(Dispatchers.IO) {
                    GroqApiClient.getParaphrases(text, persona)
                }
                
                if (paraphrases.isNotEmpty()) {
                    Log.d(TAG, "Received paraphrases with $persona persona: ${paraphrases.joinToString(", ")}")
                    updateParaphraseOptions(paraphrases)
                } else {
                    Log.e(TAG, "No paraphrases received")
                    hideParaphraseView()
                    showToast("Failed to generate paraphrases")
                }
            } catch (e: Exception) {
                Log.e(TAG, "Error getting paraphrases", e)
                hideParaphraseView()
                showToast("Error generating paraphrases")
            }
        }
    }
    
    /**
     * Apply theme updates dynamically when dark mode is toggled
     */
    /**
     * Force a complete refresh of the keyboard to reflect theme changes
     */
    private fun forceRefreshKeyboard() {
        Log.d(TAG, "Force refreshing keyboard with isDarkMode=$isDarkMode")
        
        try {
            // Update colors first
            updateColors()
            
            // Recreate the keyboard UI
            Handler(Looper.getMainLooper()).post {
                // Force the keyboard to rebuild completely
                setInputView(onCreateInputView())
                
                // Restart the input to ensure proper refresh
                currentInputConnection?.let { ic ->
                    ic.finishComposingText()
                }
                
                // Force the keyboard service to restart input
                val currentInfo = currentInputEditorInfo
                if (currentInfo != null) {
                    restartInput()
                }
                
                Log.d(TAG, "Keyboard completely refreshed with new theme")
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error during force keyboard refresh", e)
            // Fall back to the basic theme update if the full refresh fails
            applyDynamicThemeUpdate()
        }
    }
    
    private fun applyDynamicThemeUpdate() {
        Log.d(TAG, "Applying dynamic theme update with isDarkMode=$isDarkMode")
        
        try {
            // Set background color based on dark/light mode
            val backgroundColor = if (isDarkMode) Color.parseColor("#1C1C1E") else Color.parseColor("#F2F2F7")
            
            // Update keyboard colors
            keyboardBackgroundColor = backgroundColor
            keyTextColor = if (isDarkMode) Color.WHITE else Color.BLACK
            keyBackgroundColor = if (isDarkMode) Color.parseColor("#2C2C2E") else Color.parseColor("#FFFFFF")
            specialKeyBackgroundColor = if (isDarkMode) Color.parseColor("#3A3A3C") else Color.parseColor("#D1D1D6")
            
            // Apply to input view if available
            inputView?.let { view ->
                // Find container if it exists and update background
                view.findViewById<ViewGroup>(R.id.keyboard_container)?.setBackgroundColor(backgroundColor)
                
                // Update theme colors for all UI elements
                updateColors()
                
                // If needed, update any other UI elements that depend on the theme
                // For example, you might want to update button colors or text colors
                
                // Force redraw the entire view hierarchy
                view.invalidate()
                view.requestLayout()
                
                // Completely refresh the keyboard to ensure all elements are updated
                setupKeyboard()
            }
            
            Log.d(TAG, "Theme update applied successfully - all UI elements refreshed")
        } catch (e: Exception) {
            Log.e(TAG, "Error applying theme update", e)
        }
    }
    
    /**
     * Find the start index of the current sentence in the text
     */
    private fun findSentenceStart(text: String): Int {
        if (text.isEmpty()) return 0
        
        // Look for sentence terminators (., !, ?) followed by space or newline
        val lastTerminator = maxOf(
            text.lastIndexOf(". "),
            text.lastIndexOf("! "),
            text.lastIndexOf("? "),
            text.lastIndexOf(".\n"),
            text.lastIndexOf("!\n"),
            text.lastIndexOf("?\n")
        )
        
        return if (lastTerminator >= 0) lastTerminator + 2 else 0
    }
}